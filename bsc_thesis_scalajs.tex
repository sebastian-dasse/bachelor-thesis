% BESCHREIBUNG DER DOCUMENTCLASS
% a4paper 	-	weil wir ein Din-A4-Dokument benutzen.
% 12pt		-	Schriftgröße von 12 Punkt.
% listof=totoc 	-	heisst, dass das Tabellenverzeichnis (\listoftables) & das Abbildungsverzeichnis (\listoffigures) im Inhaltsverzeichnis aufgenommen werden.
% bibtotoc		-	Das Literaturverzeichnis wird ins Inhaltsverzeichnis aufgenommen.
% scrreprt		-	Das Template für diese Dokument ist ein KOMA-Script Report

\documentclass[a4paper, 12pt, hidelinks, listof=totoc, listoftables=totoc, bibliography=totoc]{scrreprt}

\usepackage{lmodern}									% Modernes Lateinisches Schriftbild benutzen
\usepackage[T1]{fontenc}								% Schriftbild glätten
\usepackage[utf8]{inputenc}								% UTF-8 als input encoding nutzen
\usepackage[ngerman]{babel}								% Deutsche Silbentrennung
\usepackage[babel, german=quotes]{csquotes}
\usepackage{xcolor}										% Damit man Farben benutzen kann
\usepackage{setspace}									%
\usepackage[a4paper]{geometry}							%
\geometry{left=25mm, right=25mm, top=25mm, bottom=25mm}	% Seitenränder setzen
\usepackage{titlesec}									%
\usepackage{graphicx}									%
\usepackage{graphics}									%
\usepackage{listings}
\usepackage{alltt}
\usepackage{nameref}\lstset{
  literate={ö}{{\"o}}1
           {ä}{{\"a}}1
           {ü}{{\"u}}1
           {Ö}{{\"O}}1
           {Ä}{{\"A}}1
           {Ü}{{\"U}}1
           {ß}{{\ss}}1
}
\usepackage{hyperref}									% für Hyperlinks
\usepackage{url}										% um lange URLs darzustellen
%\usepackage{amsmath}									% für mathematische Formeln
%\usepackage{subfigure}									% eine Möglichkeit, um Bilder nebeneinander zu plazieren
%\usepackage{subcaption}
\usepackage{subfig}										% um Bilder nebeneinander zu plazieren
\usepackage[font=footnotesize]{caption}					% nötig, um die Font-Größe für Captions festzulegen


% Bibliographie mit biblatex/biber
\usepackage[backend=biber, style=alphabetic]{biblatex}
\addbibresource{biblio_scalajs.bib}


\graphicspath{{images/}}


%\definecolor{mid-red}{RGB}{224,0,0}
%\definecolor{mid-green}{RGB}{0,160,0}
%\definecolor{dark-blue}{RGB}{0,0,160}
\definecolor{mid-gray}{RGB}{127,127,127}
\definecolor{light-gray}{RGB}{244,244,244}
%\colorlet{keyword}{dark-blue}
%\colorlet{string}{mid-red}
%\colorlet{comment}{mid-green}
\colorlet{keyword}{black}
\colorlet{string}{black}
\colorlet{comment}{black}
\colorlet{linennumber}{mid-gray}
\colorlet{background}{light-gray}


% Sprachdefinitionen für Listings
\lstdefinelanguage{Scala}{
  morekeywords={
    abstract,case,catch,class,def,do,else,extends,false,final,finally,for,%
    forsome,if,implicit,import,lazy,match,mixin,new,null,object,override,%
    package,private,protected,requires,return,sealed,super,this,throw,trait,%
    true,try,type,val,var,while,with,yield%
  },
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}
\lstdefinelanguage{JavaScript}{
  morekeywords={
    break,case,class,catch,const,continue,debugger,default,delete,do,else,%
    export,extends,finally,for,function,if,import,in,instanceof,let,new,%
    return,super,switch,this,throw,try,typeof,var,void,while,with,yield%
    null,true,false,undefined,NaN%
  },
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[b]'
}
\lstdefinelanguage{HTML5}{
  language=html,
  tagstyle=\bfseries\color{keyword},
  morecomment=[s]{<!--}{-->},
  morestring=[b]",
  morestring=[b]'
}

% Styles für Listings
\lstdefinestyle{colored}{
  keywordstyle=\bfseries\color{keyword},
  commentstyle=\itshape\color{comment},
  stringstyle=\color{string}
}
\lstdefinestyle{uncolored}{
  keywordstyle=\bfseries,
  commentstyle=\itshape,
  stringstyle=\ttfamily
}
\lstdefinestyle{numbered}{
  numbers=left,
  numberstyle=\tiny\color{linennumber}
}
\lstdefinestyle{unnumbered}{
  numbers=none
}
\lstdefinestyle{framed}{
  backgroundcolor=\color{background}
}
\lstdefinestyle{unframed}{
  backgroundcolor=
}
\lstdefinestyle{basic}{
  basicstyle={\ttfamily\singlespacing\footnotesize}, 	% andere Font-Größen: \scriptsize \footnotesize \small
  showstringspaces=false,
  breaklines=true,
  breakatwhitespace=true,
  style=unnumbered,
  captionpos=b,
  %belowcaptionskip=4pt,
  literate={`}{{\`{}}}1			% for proper backticks
}
\lstdefinestyle{standard}{
  style=basic,
  style=colored,
  style=framed
}
\lstdefinestyle{standardnocol}{
  style=basic,
  style=uncolored,
  style=unframed
}
\lstdefinestyle{htmlnocol}{
  tagstyle=\bfseries
}
\lstdefinestyle{inline}{
  basicstyle={\ttfamily\small},
  breakatwhitespace=false
}

% Default-Style für Listings. Kann überall im Text analog geändert werden.
\lstset{ style=standard }


%Arial nutzen wer will...
%\renewcommand{\rmdefault}{phv} % Arial
%\renewcommand{\sfdefault}{phv} % Arial

% FORMATIERUNG DER ÜBERSCHRIFTEN ANFANG
	% Überschriftenformatierung
	% Erklärung: \titleformat{Überschriftenklasse}[Absatzformatierung]{Textformatierung}{Numerierung}{Abstand zwischen Numerierung und Überschrift}{Code davor}[Code danach]
	% 1. Ebene chapter
	\titleformat{\chapter}[hang]{\Large\bfseries}{\thechapter\quad}{0pt}{}
	% 2. Ebene -- section
	\titleformat{\section}[hang]{\large\bfseries}{\thesection\quad}{0pt}{}
	% 3. Ebene -- subsection
	\titleformat{\subsection}[hang]{\bfseries}{\thesubsection\quad}{0pt}{}
	% 4. Ebene -- subsubsection
	\titleformat{\subsubsection}[hang]{\bfseries}{\thesubsubsection\quad}{0pt}{}

	% Platz um die Überschriften
	% Erklärung: \titlespacing{Überschriftenklasse}{Linker Einzug}{Platz oberhalb}{Platz unterhalb}[rechter Einzug]
	\titlespacing{\chapter}{0pt}{0pt}{10pt}
	\titlespacing{\section}{0pt}{20pt}{10pt}
	\titlespacing{\subsection}{0pt}{20pt}{10pt}
% FORMATIERUNG DER ÜBERSCHRIFTEN ENDE

% FORMATIERUNG FLIESSTEXT ANFANG
	% Absatzeinrueckung unterdruecken
	\setlength{\parindent}{0pt}
	% Abstand zwischen zwei Absaetzen setzen
	\setlength{\parskip}{6pt}
	% Zeilenabstand
	% Optionen: \singlespacing , \onehalfspacing , \doublespacing
	\onehalfspacing
% FORMATIERUNG FLIESSTEXT ENDE

% EIGENE KOPFZEILE ANFANG
	\usepackage{scrpage2}
	\clearscrheadfoot
	\ihead[\footnotesize{\textnormal{\headmark}}]{\footnotesize{\textnormal{\headmark}}}
	\ohead[\footnotesize{\pagemark}]{\footnotesize{\pagemark}}
	\automark{chapter}
	% Numerierung nur bis subsection
	\setcounter{secnumdepth}{2}
% EIGENE KOPFZEILE ENDE


% Wird gebraucht für die Titelseite...
\newcommand{\RM}[1]{\MakeUppercase{\romannumeral #1{}}}

% Erstellung eines Index
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN DOCUMENT // HIER FÄNGT DER INHALT AN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

% Import der Titelseite aus dem Ordner "title".
\input{./title/titlepage.tex}

% Keine Kopfzeile im Inhaltsverzeichnis
\pagenumbering{gobble}

% Inhaltsverzeichnis erstellen
\tableofcontents

% Neue Seite.
\newpage

% Kopfzeile an
\pagestyle{scrheadings}

%Seitennummern anfangen
\pagenumbering{arabic}



% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Einleitung}

%TODO Zitate checken, ggf. ergänzen um "`vgl."'

% evtl. hilfreich:  D:\UNI\2014-SoSe\GWAGWA_Themenfindung_Gliederung_Schreibstil.pdf

\section{Motivation}

% siehe jeweils Einleitung von Doeraene 2013 und Haoyi 2015

(- Weboberflächen basieren auf HTML und CSS)
- von modernen Webseiten wird in zunehmendem Maße viel Interaktionsmöglichkeiten/Interaktivität erwartet, im Vergleich zu älteren/klassischen statischen Webseiten eher Desktopanwendungen ähnlich ... (man spricht deshalb auch von Rich Internet Applications) (also: für Interaktivität auf Clientseite) existiert als De-facto-Standard JavaScript (von allen Browsern ohne Plugins unterstützt (alle Browser haben einen JavaScript-Interpreter)
-->  \url{http://w3techs.com/technologies/overview/client_side_language/all}
; mögliche Alternativen mit Plugins: Flash, Java Applets, MS Silverlight; aber beide Techniken immer weniger gebräuchlich, weil: Flash Video-Player seit HTML5 video Bedeutungsverlust, Flash-Format für animierte Inhalte ersetzt durch JS-Bibliotheken wie etwa jQuery und HTML5-Techniken wie <canvas>, SVG und WebGL, Silverlight deprecated, Applets lange Ladezeiten), verlieren aber zunehmend an Bedeutung  -->  Diagramm:   \url{https://www.google.com/trends/explore#q=adobe+flex,microsoft+silverlight,java+applet,HTML5,gwt}
- JavaScript aus verschiedenen Gründen problematisch
  - nicht typsicher (-> Fehler zur Laufzeit)
  - unerwartetes Verhalten (schwer zu findende Fehler)
  - relativ "`verbose"'/geschwätzig
  - schlechte Wartbarkeit
  - aufwendiges Refactoring
- eine Sprache für beide Seiten, Client und Server, wünschenswert
  - auf Serverseite in der Regel andere Sprache wie Java, PHP, ... ???
  - Vorteile wären: Wiederverwendbarkeit von Code, Definition gemeinsamer Schnittstellen (in der Form bisher nicht möglich)

- Scala.js bringt Scala (bisher auf Basis der JVM) auf die Client-Seite:
  - es kann in Scala entwickelt werden
  - Scala-Code wird nach JavaScript als Zielsprache übersetzt
  - Compiler, Ökosystem aus Bibliotheken und Tools/Entwicklungswerkzeugen



\section{Zielstellung / Aufgabenstellung}

Ziel: untersuchen, wie gut Scala.js zur Entwicklung von Weboberflächen geeignet ist
Fragen:
  - entwickelt man robuster?
  - steigert es die Code-Qualität?
  - entwickelt man schneller?
  - ist es angenehm, mit Scala.js zu entwickeln?
  - kann das Resultat mit herkömmliche Weise mit JavaScript entwickelten Anwendungen mithalten oder übertrifft es sie sogar?
  - entsprechend: ist das Ergebnis performant genug?
  - aus Benutzersicht: wie schnell lädt die Seite?

Anhand verschiedener kleinerer Anwendungen / anhand der Anwendung ... soll untersucht werden, wie gut Scala.js den heutigen Anforderungen an die Frontend-Entwicklung gerecht wird.


Abgrenzung:

	NICHT IM FOKUS: Browser-Kompatibilität
	NICHT IM FOKUS: Server mit Datenbank
	NICHT IM FOKUS:  ist es gut/schlecht viel clientseitigen JS-Code zu haben - möglicherweise besser, mehr statisches HTML zu serven, und nur Teile dynamisch durch JS erzeugen zu lassen?


\section{Aufbau der Arbeit}

TODO






















% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Technikvorstellung/fachliches Umfeld/Grundbegriffe (3)}

\section{Scala (1.5)}

%-->  \cite{fiedler2011.ELS} S. 5-8

%TODO kürzen!

Scala ist eine moderne Multiparadigmen-Programmiersprache, die objektorientierte und funktionalen Programmierkonzepte mit einer statischen Typisierung verbindet. Sie wird seit 2001 federführend von Martin Odersky an der École polytechnique fédérale de Lausanne entwickelt und wurde erstmals 2004 öffentlich vorgestellt.
%"`Scala smoothly integrates object-oriented and functional programming. It is designed to express common programming patterns in a concise, elegant, and type-safe way."'  --> \url{http://article.gmane.org/gmane.comp.lang.scala/17}
Seit der Gründung der Firma Typesafe 2011 durch Odersky und Jonas Bonér\footnote{
	Bonér ist der Autor von \textit{Akka}, einem Toolkit und einer Laufzeitumgebung zur Entwicklung fehlertoleranter nebenläufiger und verteilter Anwendungen. Es basiert auf einem Modell, bei dem \textit{Aktoren} genannte nebenläufige Einheiten durch Nachrichtenaustausch miteinander kommunizieren. Akka ist Teil der Typesafe-Plattform. \url{http://akka.io/}}
erfährt die Entwicklung von Scala als Teil der \textit{Typesafe Reactive Platform} nun auch kommerzielle Unterstützung.
Hier wird unter anderem die IDE-Integration für Scala vorangetrieben und das Buildtool \textit{sbt} entwickelt.\cite{scala-lang2011.CSS} 

Scala verwendet eine prägnante, schlanke Syntax. So lässt sich etwa eine einfache Klasse als Einzeiler schreiben: \texttt{class Foo(val bar: Int)}. Damit sind sowohl ein Konstruktor als auch die Instanzvariable (\texttt{bar}) definiert. Dadurch sind Scala-Programme eher kurz. Ein Java-Programm lässt sich mit etwa der halben Anzahl an \textit{Lines of Code} in Scala formulieren. Das reduziert den Schreib- und Leseaufwand und die Gelegenheit Fehler zu machen.

Scala erlaubt es, auf einem relativ hohen Abstraktionslevel zu programmieren und macht es so erleichtert den Umgang mit komplexen Systemen.

Scala-Programme kompilieren zu Java-Bytecode und laufen auf der JVM\footnote{
	\textit{Java Virtual Machine}}. 
Ihre Performance ist mit der von Java-Programmen vergleichbar. Scala-Code kann Java-Code aufrufen. Dadurch hat der Scala-Programmierer\footnote{
	GENDERKLAUSEL: der Einfachheit halber wird im Text die männliche Form verwendet; natürlich ist auch die Programmiererin gemeint.} 
automatisch auch alle Libraries zur Verfügung. Scala-Code kann auch von Java-Code aufgerufen werden, aber hier sind manchmal einige Feinheiten zu beachten.\cite[S. 13 ff.]{odersky2008.PIS}

Der Einstieg in die Sprache Scala ist relativ einfach. Durch die Mächtigkeit der Sprachmittel und die Vielzahl der sich daraus ergebenden Möglichkeiten ist für eine tieferes Verständnis allerdings ein hoher Lernaufwand nötig.

%(>>Wurzeln: Syntax ähnlich Java, ML)


\subsection{Objektorientierung}

Scala ist eine rein objektorientierte Sprache: Jeder Wert ist ein Objekt. Das schließt auch numerische Werte und Funktionen ein, primitive Typen wie in Java existieren nicht. Doch die Objektorientierung geht sogar noch weiter: In Scala ist jede Operation ein Methodenaufruf. So ist \texttt{1 + 2} der Aufruf der Methode \texttt{+} an einer Instanz der Klasse \texttt{Int} und könnte auch als \texttt{1.+(2)} ausgedrückt werden. Konsequenterweise sind auch statische Methoden unbekannt. Stattdessen werden mit dem Schlüsselwort \texttt{object} Singleton-Objekte definiert, die Methoden und Werte aufnehmen können, welche nicht Attribute der Instanz einer Klasse sind. Diese können entweder alleinstehend sein oder als sogenanntes Begleitobjekt (\textit{companion object}) einer gleichnamigen Klasse auftreten.

Benutzerdefinierte Typen lassen sich mithilfe von Klassen und \textit{Traits} definieren. Traits sind den Interfaces in Java ähnlich, sie können allerdings Implementierungen von Methoden und sogar Felder enthalten. Außerdem können Traits mehrfach beerbt werden (man spricht hierbei auch von \textit{mixin class composition}).

Die Modularisierung von Programmen funktioniert grundsätzlich ähnlich wie in Java, allerdings stellt Scala flexiblere und generischere Mittel zur Verfügung. Importe können grundstäzlich überall platziert werden. Dabei können neben Paketen und Paket-Membern auch Objekte importiert werden. Member können auch unter anderem Namen importiert werden, sei es um Namenskonflikte zu vermeiden oder um häufig verwendete Namen abzukürzen.
Pakete können, anders als in Java, beliebig verschachtelt werden. Die Zugriffsmodifizierer werden konsistenter und granularer als in Java gehandhabt. Beginnt etwa die Deklaration einer Methode mit \texttt{private[this]}, so darf nur durch das Objekt selbst auf diese Methode zugegriffen werden.\cite[S. 9 f., S. 233 ff.]{odersky2008.PIS}\cite{scala-lang.ATS}

\subsection{Funktionale Programmierung}

%funktional (aber auch imperativ)

%Scala unterstützt funktionale Programmierung.
Scala ist eine vollständig funktionale Sprache.\footnote{
	Funktionale Programmierung basiert auf dem in den 1930er Jahren von Alonzo Church entwickelten Lambda-Kalkül. Dessen zentrale Idee besteht darin, dass Funktionen anonym definiert werden. Das Lambda-Kalkül ist Turing-vollständig, und somit gleich mächtig wie imperative Sprachen. Jedes imperative Programmierkonstrukt lässt sich demnach auch funktional ausdrücken.}
Funktionen sind in Scala \textit{first-class values}, das heißt sie haben denselben Status wie alle anderen Daten. Sie können einer anderen Funktion als Parameter übergeben werden oder von einer anderen Funktion zurückgegeben werden. Diese "`andere"' Funktion bezeichnet man als Funktion höherer Ordnung. Funktionen können ineinander verschachtelt werden und anonym als \textit{Funktionsliterale} (oft auch Lambda-Funktionen genannt) verwendet werden.

Funktionen bilden Eingabewerte auf Ausgabewerte ab, ohne dabei den Zustand der Eingabewerte zu verändern. Man sagt: Sie sind frei von Nebenwirkungen (\textit{side effects}). Zusätzlich sind Funktionen referentiell transparent, das heißt sie liefern für gleiche Argumente immer das gleiche Ergebnis. Für jeden Eingabewert kann der Funktionsaufruf durch sein Resultat ersetzt werden, ohne dass sich dadurch die Semantik ändert. Durch diese Eigenschaften wird die funktionale Programmierung zunehmend attraktiv für den Einsatz in nebenläufigen Programmen. Einfach ausgedrückt: Werte die sich nie ändern müssen auch nicht synchronisiert werden.

Darüberhinaus kennt Scala \textit{Closures}, \textit{Currying} und \textit{List comprehensions}\footnote{
	in Scala: \textit{Sequence comprehensions}
}.

Scala unterstützt zwar die nebenwirkungsfreie funktionale Programmierung mit unveränderlichen (\texttt{immutable}) Daten, lässt einem aber die Wahl, gegebenenfalls im imperativen Stil zu programmieren.\cite[S. 6 ff.]{piepmeyer2010.GFP}\cite[S. 10 ff.]{odersky2008.PIS}

\subsection{Einheitliches statisches Typsystem}

Scala verfügt über ein ausdrucksstarkes einheitlich Typsystem mit einer gemeinsamen Superklasse \texttt{Any} von der jede Klasse erbt. \texttt{Any} hat exakt zwei direkte Subklassen: \texttt{AnyVal} und \texttt{AnyRef}. 

Von \texttt{AnyVal} erben die neun Scala-eigene Werteklassen: \texttt{Byte}, \texttt{Short}, \texttt{Char}, \texttt{Int}, \texttt{Long}, \texttt{Float}, \texttt{Double} und \texttt{Boolean}, die den primitiven Typen in Java entsprechen\footnote{
	sie werden sogar zur Laufzeit durch primitive Java-Typen ersetzt}
und \texttt{Unit}, das etwa \texttt{void} in Java entspricht. \texttt{AnyRef}, die andere Subklasse von \texttt{Any}, ist die Basisklasse für alle Referenzklassen. Auf der Java-Plattform ist \texttt{AnyRef} nur ein Alias für die Klasse \texttt{java.lang.Object}. 

Außerdem existieren noch zwei spezielle Klassen: \texttt{Null} und \texttt{Nothing}. \texttt{Nothing} ist eine gemeinsame Subklasse jeder anderen Klasse. Dieser Typ kann keine Werte enthalten, wird aber benötigt um zum Beispiel den Typ der leeren Liste zu definieren: \texttt{List[Nothing]}. Die Klasse \texttt{Null} enthält \texttt{null} als einzigen Wert und ist der Subtyp aller Rerenzklassen, also aller Klassen, die von \texttt{AnyRef} erben.

Scala ist statisch typisiert, das bedeutet es findet eine Typprüfung zur Compile-Zeit statt. Daraus leiten sich sich verschiedene entscheidende vorteilhafte Eigenschaften ab. Ein Typ ist nichts anderes als die Festlegung des Wertebereichs und der möglichen Operationen für ein Objekt. Ist der Typ eines Objekts bekannt, so werden an ihm beispielsweise nie Methoden aufgerufen oder auf Attribute zugegriffen werden können, die er nicht besitzt. Solche Programmierfehler würde der Compiler melden und das Programm einfach nicht übersetzen. Mit der statischen Typprüfung sind demnach echte Garantien verbunden, die bestimmte Laufzeitfehler sicher ausschliessen, und zwar sicherer als jeder Unit-Test.

Diese Typsicherheit bedeutet auch eine größere Sicherheit beim Refactoring und eine deutlich stärkere Unterstützung durch IDEs: beim Refactoring, bei der komfortablen Quellcodenavigation (wie etwa das Springen zur Definition eines Werts) und durch typbasierte automatische Code-Vervollständigung. Nicht zuletzt ist Code automatisch besser dokumentiert, wenn die Typen der Attribute, Parameter und Funktionsrückgabewerte bekannt sind.

Trotz strenger Typisierung erlaubt Scala einen flexiblen Umgang mit seinen Typen. Durch ein System der automatischen Typableitung (\textit{Typinferenz}) werden redundante Typangaben vermieden und häufig kommen Deklarationen sogar ganz ohne explizite Typangaben aus. Der eingebaute Mechanismus des \textit{Pattern Matching}\footnote{
	raffinierte Form Version einer switch-Anweisung anhand der Struktur oder dem Typ eines Objekts}
erlaubt einen sehr flexiblen Umgang mit streng getypten Werten.

Außerdem erlaubt Scala generische Klassen, innere Klassen, abstrakte Typen als Member, zusammengesetzte Typen (\textit{compound types}) und implizite Parameter.\cite[S. 16 ff., S. 205 ff.]{odersky2008.PIS}\cite[S. 113 ff.]{piepmeyer2010.GFP}\cite{scala-lang2011.CSS}

\subsection{Erweiterbarkeit}

Scala trägt die Erweiterbarkeit im Namen ("`scalable language"').
%"eine Sprache die mitwächst" ("a language that grows on you")
Die Sprache hat einen relativ kompakten Kern und liefert einen großen Umfang an Funktionalität in Form einer Standardbibliothek. Diese enthält unter anderem ein äußerst unfangreiches Collections-Framework, eine Mathematik-Bibliothek, Bibliotheken für reguläre Ausdrücke, zur XML-Manipulation, zur nebenläufigen Programmierung mit Futures und Promises und eine Aktoren-Bibliothek, welche Nebenläufigkeit durch Nachrichtenaustausch realisiert.\footnote{Einen guten Überblick über die Standardbibliothek bietet die API-Dokumentation: \url{http://www.scala-lang.org/api/current/\#package}}

Die Sprache stellt aber auch mächtige Mittel zur Verfügung, um flexible Libraries und DSL\footnote{\textit{domain-specific languages}}s zu entwickeln. Zum Beispiel kann die Vererbung durch die Kombination beliebig vieler Traits sehr flexibel gehandhabt werden. Es ist ferner möglich, implizite Konvertierungen zu definieren. Die Infix- und Postfix-Notation in Verbindung mit der erlaubten Verwendung von Sonderzeichen für Methodennamen erlaubt es, eigene Operatoren zu schreiben (\texttt{1 + 2} ist die Infix-Notation für \texttt{1.+(2)} ). Es ist sogar möglich eigene Kontrollstrukturen zu erzeugen, indem man Methoden mit Operationen parametrisiert\footnote{
	durch \textit{by-name evaluation}}.\cite[S. 4 ff.]{odersky2008.PIS}

\subsection{Tools und Ökosystem}

Scala wird mit einem sehr nützlichen interaktiven Kommandozeilen-Interpreter ausgeliefert (auch REPL genannt, kurz für \textit{read-eval-print loop}).

Zur IDE-Integration existieren Plugins für Eclipse\footnote{
	es existiert auch eine komplette Eclipse-basierte Scala IDE}, 
IntelliJ IDEA und NetBeans.

Für Tests eignet sich ScalaTest, das viele unterschiedliche Teststile unterstützt. Auch die in der Java-Welt etablierten Frameworks JUnit und TestNG können verwendet werden.

Mit \textit{sbt} existiert ein Buildtool, das Scala-Projekte der De-facto-Standard ist. Aber auch mit Ant und Maven sind Builds möglich.

Auf der Scala-Website finden sich neben der API-Dokumentation auch offizielle Tutorials und ein Style Guide.\footnote{\url{http://docs.scala-lang.org/}}



\section{JavaScript (1.5)}

JavaScript ist eine dynamische Skriptsprache\footnote{Das heißt sie wird zur Laufzeit ausgewertet und in Maschinencode übersetzt.} die, es erlaubt objektorientiert und funktional zu programmieren. Sie wurde 1995 von Brendan Eich für Netscape innerhalb von zehn Tagen entwickelt\cite{wikipedia.JS}. Der primäre Zweck von JavaScript ist es, aus statischen Webseiten interaktive Webanwendungen machen\cite[S. 361]{flanagan2011.JDG}. Der Sprachstandard wird unter dem offiziellen Namen ECMAScript (kurz: ES) von der Organisation Ecma International standardisiert (als Standard ECMA-262). Der aktuell von allen wichtigen Browsern unterstützte Standard ECMAScript 5.1 stammt aus dem Jahr 2011\footnote{\url{http://www.ecma-international.org/ecma-262/5.1/}}. Die im Juni 2015 veröffentlichte Version ECMAScript 6 enthält viele Verbesserungen um die Sprache zu modernisieren, ist aber momentan noch nicht ausreichend in den verbreiteten Browser implementiert.

Die Syntax von JavaScript ähnelt zu großen Teilen der des ungleichen Namensvetters Java, die Semantik unterscheidet sich hingegen in Teilen stark\cite{eich1996.JSL}.

warum JS?
wo läuft JS?


\subsection{Objektorientierung}

JavaScript ist eine objektorientierte Sprache. Objekte auf können auf drei Arten erzeugt werden:

\begin{itemize}
	\item als Literal: \lstinline[language=JavaScript, style=inline]|var foo = {bar: 123}|
	\item mit \texttt{new} gefolgt vom Aufruf einer Konstruktor-\texttt{function}
	\item seit ES5 mit \lstinline[language=JavaScript, style=inline]|Object.create()|, wobei als Parameter der Konstruktor übergeben werden muss.
\end{itemize}

Objekte haben Eigenschaften (\textit{properties}), die primitive Werte, Referenzen auf andere Objekte, oder Methoden sein können.

Properties eines Objekts können neben der geläufigen Punkt-Notation (\texttt{foo.bar}) auch durch den in eckigen Klammern eingeschlossene Membernamen als String (\texttt{foo["bar"]}) referenziert werden. Bei JavaScript-Objekten handelt es sich nämlich im Grunde um Collections benannter Werten, das heißt sie sind nichts anderes als assoziative Arrays (in Scala: \textit{Map}, in anderen Sprachen gelegentlich auch: \textit{Dictionary}), und werden auch bei Bedarf als Maps verwendet.

Das Konzept von Klassen ist nicht Teil der Sprache. Vererbung funktioniert in JavaScript über den Prototypen. Dazu referenziert jedes JavaScript-Objekt ein anderes Objekt, deren Eigenschaften es erbt: den Prototypen. Objekte die vom selbem Prototypen erben kann man als Klasse auffassen.\cite{mdn.WWO}\cite[S. 115 ff., S. 199 ff.]{flanagan2011.JDG}

\subsection{Funktionale Programmierung}

Funktionen sind in JavaScript \textit{first-class citizens}. Sie können in Variablen gespeichert oder verschachtelt werden, können als Parameter übergeben werden oder als Rückgabewert einer Funktion dienen. Damit sind auch Funktionen höherer Ordnung möglich. Ein häufiger Anwendungsfall für Funktionen höherer Ordnung in JavaScript sind sogenannte Callback-Funktionen. Ein andere sind Closures. Durch \textit{Currying} lässt sich auch die partielle Anwendungen von Fuktionen umsetzen. --- All das aber im Vergleich zu Scala mühsamer und verbose.

Die Behandlung von Funktionsparametern ist in JavaScript äußerst flexibel. Werden beim Funktionsaufruf weniger Parameter übergeben als im Methodenheader deklariert sind, erhalten diese automatisch den Wert \texttt{undefined}. Werden zu viele Parameter übergeben, so werden diese einfach ingoriert. Auf alle tatsächlich übergebenen Argumente einer Funktion kann innerhalb einer \texttt{function} durch eine Liste namens \texttt{arguments} zugegriffen werden, unabhängig vom Methodenheader.

Mit dem Schlüsselwort \texttt{this} wird innerhalb einer \texttt{function} der Aufrufkontext referenziert. Das ist dasjenige Objekt, \textit{an} dem oder \texttt{durch} das die Methode aufgerufen wurde. 
\cite[199 ff.]{flanagan2011.JDG}

\subsection{Dynamische, schwache, implizite Typisierung}

JavaScript ist eine in äußerstem Maße dynamische Sprache. Objekte können in JavaScript zur Laufzeit grundlegend verändert werden. Methoden können hinzugefügt, Methoden zu Attributen gemacht oder durch andere Methoden ersetzt werden.

Variablen sind in JavaScript nicht typisiert. Daher kann einer Variablen erst ein Wert vom Typ A und später ein Wert vom Typ B zugewiesen werden. Außerdem finden in JavaScript viele implizite Konvertierungen statt, wenn in einem Programm ein anderer als der erwartete Typ verwendet wird, zum Beispiel von \texttt{Number} nach \texttt{String} oder von einem beliebigen Typ nach \texttt{Boolean}.

JavaScript unterscheidet nur wenige Datentypen. Es gibt die primitiven Typen: \texttt{Boolean}, \texttt{Number} und \texttt{String}. 
Dabei werden alle Zahlen ohne Unterscheidung zwischen Ganz- und Fließpunktkommazahlen als \textit{float} repräsentiert. Alle primitiven Typen sind \textit{immutable}.

Alle primitiven Typen außer \texttt{null} und \texttt{undefined} werden als Objekte behandelt. Dazu existieren Wrapper, in welche die primitiven Typen bei Bedarf automatisch konvertiert werden. Auf diese Weise können beispielsweise Methoden der Wrapper-Klasse \texttt{String} direkt an einem Stringliteral aufgerufen werden (\lstinline[language=JavaScript, style=inline]|"foo".toUpperCase()|).

Daneben existieren zwei spezielle Werte: \texttt{undefined}, für Variablen ohne zugewiesenen Wert, und \texttt{null}, die "`kein-Objekt"'-Referenz (verwirrenderweise vom Typ \texttt{Object}).

Alle Typen außer den primitiven Typen und \texttt{null} und \texttt{undefined} sind \textit{mutable}.

\texttt{Object} ist der Datentyp für alle Referenztypen, der wie beschrieben, manchmal auch explizit als Collection verwendet wird. \texttt{Array} ist der einzige Typ für geordnete Collections.

Es gibt den Typ \texttt{Function} für Funktionen. Daneben existieren nur noch \texttt{Date}, \texttt{Error}, \texttt{Math} und \texttt{Regexp}.
\cite[S. 29 ff.]{flanagan2011.JDG}

\subsection{Tools und Ökosystem}

Die Plattform auf der JavaScript ausgeführt wird ist klassischerweise der Browser. Dieser benötigt zur Ausführung von JavaScript eine JavaScript-Engine die den Code zur Laufzeit interpretiert. Moderne JavaScript-Engines sind aber aus Performancegründen meist keine Interpreter mehr, sondern führen eine Just-in-time-Kompilierung (JIT)\footnote{
	\url{https://en.wikipedia.org/wiki/Just-in-time_compilation}
} durch. Verbreitete JavaScript-Engines sind:

\begin{itemize}
	\item Nitro (Apple Safari)
	\item V8 (Google Chrome und Opera)
	\item SpiderMonkey (Mozilla Firefox)
	\item PhantomJS (ein auf WebKit basierender sogenannter \textit{headless browser}, der zum Beispiel für Tests zum Einsatz kommt)
\end{itemize}

Darüber hinaus ist in den letzten Jahren auf der Serverseite Node.js (V8) als JavaScript leichtgewichtige Laufzeitumgebung populär geworden.

Vorteile der JavaScript-Plattform:
- Web-Anwendungen müssen vom Benutzer nicht installiert werden, können einfach im Browser aufgerufen werden
- Referenzen zwischen verschiedenen Systemen durch Hyperlinks
- Sicherheit durch Sandbox-Prinzip\footnote{
	kein Zugriff aus dem Browser heraus (begrenzte Ausnahme: Zugriff auf User-bestimmte Dateien durch File API)}
\cite[\#Javascript-the-platform]{haoyi.HOS}

(IDEs: ???)


\subsection{Besonderheiten / Probleme - TODO mit Problemen zusammenfassen}

>>lexical scope (Variablen ohne var global)
>>function scope, trotz blockbasierter Syntax
Bsp.
var i = 123
for (var i = 0; i < 10; i++) { /**/ }
console.log(i) // --> 123

>>Prototyp-basiert
- statt Klassen
-> ein bereits existierendes Objekt wird geklont
- Programmierern die von anderen Sprachen kommen nicht vertraut
- Klassen möglich, mit Pattern; künftig mit ES6 mit Sprachmitteln
Seit ES5 getter und setter möglich, aber keine echt privaten Member, kann nur umständlich mithilfe von Closures emuliert werden
(siehe \cite[S. 226]{flanagan2011.JDG})

>>Arrays (Collections)
Objekt als assoziatives Array / Hashmap / Hashtabelle / Dictionary
- können als foo["mykey"] oder foo.mykey adressiert werden
Array einzige "Collection"

Set, Map, auch WeakSet und WeakMap (mit weak references die von der Garbage Collection aufgeräumt werden, gegen Memory Leaks) -> ES6, noch nicht von allen Browsern unterstützt, aber es existieren sog. Polyfills (https://en.wikipedia.org/wiki/Polyfill)

>> keine Konstanten (aber mit ES6)

>>Probleme mit uneindeutigem/unintuitivem this
- this referenziert das aufrufenden Objekt, bei Closures problematisch; behelfsweise kann this in der Closure in einer Variablen (häufig self genannt) gemerkt und diese übergeben werden

>>Kapselung, Modularisierung
- kein Zugriffsmodifizierer/Schlüsselwort private
-> behelfsweise kann Privatheit emuliert werden, aber sperrig
	- mithilfe von Closures private Instanzvariablen (innerhalb der Konstruktorfunktion definieren)
	- mithilfe anonymer Funktionen (function-Scope)
- keine Pakete oder Namespaces als Teil der Sprache
-> kann durch Patterns geschaffen werden
-> Libraries wie RequireJS oder verschiedene Frameworks bieten Mechanismen zu Modularisierung

- Traits und Mixins möglich, aber nicht als Teil der Sprache (\url{https://en.wikipedia.org/wiki/JavaScript#Implicit_and_explicit_delegation}

unstrukturiert: JavaScript gibt keine Struktur vor


>> Standard
- neuer Standard ECMAScript 6 im Juni 2015 veröffentlicht
	- Konstanten mit const
	- block-scoped variablen (mit let statt var) und functions
	- Lambdas/anonyme Funktionen -> in JS sog. arrow functions (dann möglich: [1, 2, 3].map(x => x * x) statt bisher [1, 2, 3].map(function(x) { return x * x; }) )
	- lexikalisches this - intuitivere Behandlung des Objektkontextes
	- Defaultwerte für Parameter, eine Art Varargs
	- variadische Funktionen mit Parameter
	- String Interpolation (\texttt{var person = \{ name: "Foo" \}; var message = `Hello \$\{person.name\}!`})
	- Destructuring Assignment, mit dem Arrays oder Objekte bei der Zuweisung in ihre Bestandteile zerlegt werden können
	- Klassen mit class, constructor, getter und setter, Vererbung mit extends, Zugriff auf Superklassen mit super
	- Iterator, der mit einem For-Of-Operator verwendet werden kann
	- komfortable Methoden für den Umgang mit Strings und Zahlen (Number.isNan(42), Number.isFinite(42) )
	- Promises zum Umgang mit Asynchronität
	-->  \url{es6-features.org}
	-->  \url{http://www.ecma-international.org/publications/standards/Ecma-262.htm}
- Firefox und Chrome unterstützen schon viele Features, aber meistens noch als experimentell gekennzeichnet, noch nur teilweise schon in
in allen aktuell Browsern voll unterstützt: ECMAScript 5 (von 2009) bzw. 5.1 von 2011 (???)



Eigenschaften (nach Schirmacher-Folie, S. 5: %D:\UNI\2014-SoSe\CG2\VL)
	funktional
	objektorientiert
	dynamisch
	unstrukturiert
	Typisierung (vgl. %http://de.wikipedia.org/wiki/Typisierung_(Informatik))
	Arrays
	Probleme mit uneindeutigem this
	Kapselung - mithilfe anonymer Funktionen
	
                             
>>Probleme von JavaScript
- häufig unerwartetes Verhalten / nicht erwartungskonform  -->  Bsp.e
- fehlende Typsicherheit  -->  Bsp.e
- function scope, nicht block scope
- Vererbung mit Prototypen; kein Standard zur Modellierung von Klassen, viele verschiedene Möglichkeiten  ->  Chaos, Hürde für Programmierer die von anderen Sprachen wie Java oder C++ kommen
-->  Doeraene
- ...
-->  BA Wiederhold
- funktionale Methoden: map, filter reduce, forEach -- Support, Performance
- im Browser: kann deaktiviert sein, aber verschwindender Prozentsatz der Nutzer tut dies  -->  \url{https://developer.yahoo.com/blogs/ydn/many-users-javascript-disabled-14121.html}
	- hier ist es sinnvoll, zu unterscheiden zwischen Web-Dokumenten, die auch ohne JavaScript zugänglich sein sollten, und Web-Anwendungen, von denen man das nicht erwarten kann, schließlich handelt es sich bei diesen um JavaScript-Programme (mit dem Browser als Plattform/OS)
	\cite[S.311]{flanagan2011.JDG}

-->  \cite{flanagan2011.JDG}
-->  \cite{crockford2008.JSG}
Brendan Eich: Zitat  -->  \url{https://www.jwz.org/blog/2010/10/every-day-i-learn-something-new-and-stupid/#comment-1021}
-->  \url{https://en.wikipedia.org/wiki/ECMAScript}

- Problem: Browser-Inkompatibilitäten
- Problem: vieles in der Sprache unspezifiziert, Lösungen dafür existieren, aber sehr viele Arten, etwas zu tun (viele verschiedene Patterns, viele verschiedene Frameworks)

- notorisch schwer zu debuggen - Fehlermeldungen wie: foo is not a function, durch die sich häufig nicht die eigentliche Fehlerursache zurückverfolgen lässt


- häufig benutzte clientseitige / Frontend- Frameworks geben (ihre) Struktur, müssen aber jedesmal erst neu gelernt werden


\section{HTML(0.5)}

%-->  https://de.wikipedia.org/wiki/Hypertext_Markup_Language
%-->  https://en.wikipedia.org/wiki/HTML
%-->  https://de.wikipedia.org/wiki/HTML5
%-->  https://en.wikipedia.org/wiki/HTML5
%-->  http://www.w3.org/2014/10/html5-rec.html.en

>>Was ist HTML?
	- Kernsprache des Webs (bei erster Nennung: World Wide Web)
	- HTML (Hypertext Markup Language)
	- Auszeichnungssprache zur Erstellung von Webseiten
	- Browser können sie lesen und darstellen
	- strukturiert durch verschachtelte HTML-Elemente, repräsentiert durch Tags, geschrieben mit spitzen Klammern
		- können Attribute enthalten, Key-Value-Paare (= Schlüssel-Wert-Paare)
		- z.B. <p color="blue">ein Absatz</p>
		- wichtig:
			- id - eindeutige ID
			- class - zur Klassifizierung von Elementes; aus semantischen Gründen oder zu Präsentationszwecken (gleiche Klasse -> gleiche Darstellungsregeln); ein Element kann mehreren Klassen zugeordnet werden
			- style - Präsentationseigenschaften (-> CSS)
			(- title - wird von den meisten Browsern als sog. Tooltip angezeigt)
	- Grundstruktur
		- Deklaration des Dokumententyps (DTD)
		- head = Kopf - nicht angezeigte Infos
		- body = Körper - Infos zur Anzeige; in der Praxis aber auch unsichtbare Infos
	
>>seit wann?
	- seit 1993
>>von wem?
	- entwickelt vom W3C und WHATWG
(>>Eigenschaften)

(>>einfaches Beispiel-HTML)

>>aktuell HTML5
	- aktuelle 5. Fassung von HTML  -->  \url{http://www.w3.org/TR/html5/}
	- Oktober 2014 vom W3C unter dem Namen "`W3C Recommendation"'  -->  \url{https://www.w3.org/blog/news/archives/4167}
	- "`HTML \& friends"' - zusätzliche JavaScript-APIs, meistens mitgemeint, wenn von HTML5 die Rede ist
		- semantische Tags (section, article, nav, head, footer, aside)
		- Connectivity: WebSockets
		- Storage: File API, Web Storage API, IndexedDB, 
		- Multimedia: audio, video (leider kein Standard für verlässlich unterstützte Multimediaformate), Camera API
		- Grafik: Canvas, WebGL, SVG
		- Performance und Integration: XMLHttpRequest, Drag and drop, Web Workers
	-->  \url{https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5}
	- leider keine offizielle, leicht navigierbare HTML5-API-Docs, guter Überblick: \url{http://html5index.org/}

- JS und HTML
	- Einbindung:
		- inline, innerhalb der Tags <script> </script>
		- (normalerweise am besten:) in einer separaten/externen Datei, z.B.: <script src="../js/greeting.js"></script>
		- in einem HTML-Eventhandler-Attribut eines HTML-Eements, z.B.: <button onclick="alert('hello');">
		- in einer URL, mithilfe des javascript:-Protokolls, z.B.: <a href="javascript:alert('hello');">greeting</a>

- DOM  --> \url{https://en.wikipedia.org/wiki/Document_Object_Model}
	- durch W3C standardisierte Schnittstellenspezifikation ...
	- Standard seit 1998
	- aktuelle Version: DOM Level 3 (von 2004) von allen gängigen Browsern unterstützt
	- Baumstruktur für Dokumente, mit Knoten für die einzelnen HTML-ELemente; der Wurzelknoten ist das document-Objekt
	- wenn ein Browser eine Website rendert:
		- HTML-Dokument wird in lokalen Speicher geladen
		- geparset
		- auf dem Bildschirm angezeigt
		- dabei wird intern ein Modell ähnlich dem DOM verwendet
		- ein DOM wird erzeugt
	- JavaScript kann:
		- den DOM manipulieren
		- durch den DOM navigieren
		- alle Elemente und deren Attribute ändern
		- Elemente erzeugen, hizufügen oder entfernen und auf Ereignisse der im DOM repräsentierten Website reagieren



\section{CSS (0.5)}

>>seit wann?
>>von wem?
  seit 1996 vom W3C standardisiert
  mit CSS3 nicht eine Spezifikation, sondern aufgebrochen in verschiedene Module mit unterschiedlicher Stabilität und Reifegrad (vier davon haben den höchsten Status "`W3C recommendation"')
>>Was ist CSS?
>>Eigenschaften
	- (Cascading Style Sheets)
	- Standard zur visuellen Darstellung von HTML-Dokumenten / von Webseiten
	- Designer können präzise Schriftarten, Farben, Ränder, Einrückungen, Rahmen und Positionen von Elementen spezifizieren
	- kann gescripted werden
	- CSS definiert style properties für Fonts, Farben, Anstände usw.; diese properties können festgelegt werden um die Darstellung zur verändern
	- zwei Möglichkeiten, CSS-Eigenschaften festzulegen:
		- inline: style-Attribut eines HTML-Elements (<p style="color: red">foo</p>
		- prinzipiell besser: in einem separaten Stylesheet
			- Mengen von style properties können Mengen von HTML-Elementen zugeordnet werden ("`A stylesheet associates set sof style properties with sets of HTML elements that are described using selectors."')
			- Selektoren
				\#foo // ein Element mit id="foo"
				div  // alle <div>-Elemente
				.bar // alle Elemente, deren class-Attribut "bar" enthält
				div.bar, \#foo>span // alle <div>-Elemente deren class-Attribut "bar" enthält und alle Kind-<span>-Elemente des Elements mit id="foo"
				* // alle Elemente
			- Stylesheets können in einem <style>-Element im <head> eines HTML-Dokuments eingebunden werden
			- besser ist es aber (warum?) ein Stylesheet in einem eigenen Dokument zu speichern und es durch ein <link> im <head> einzubinden (Bsp.?)
	- Anwendung der Stilregeln in der Rangfolge (steigender Priorität):
		- Standard des Browsers
		- die Stylesheets die im Dokument referenziert/verwendet werden
		- die style-Attribute individueller HTML-Elemente
		- generell "`gewinnt"' der spezifischere Selektor und überschreibt Stildefinitionen für gleichlautende Eigenschaften, z.B. Stylesheet: div { color: red; background: green; }, HTML: <div style="color: blue;">foo</div>
	-->  vgl. \cite[S. 413 ff.]{flanagan2011.JDG}
	\url{https://en.wikipedia.org/wiki/Cascading_Style_Sheets}


\section{sbt}

sbt\footnote{\url{http://www.scala-sbt.org/}} ist das Build-Werkzeug für Scala-Projekte aus dem Hause Typesafe. Es ist noch relativ neu, ist aber 

- Konvention über Konfiguration wie Maven, d. h. nur Abweichungen von der Konvention müssen definiert werden
- Verzeichnisstruktur entspricht standardmäßig der von Maven (nämlich), muss aber selbst erstellt werden

- einige wichtige Kommandos
	compile
	test
	run
	package
	clean

- unterstützt die Kompilierung von Scala-Code
- kann als Testrunner für Scala-Test-Werkzeuge verwendet werden
- Build-Definition
	- in einer scalabasierten DSL (statt XML-basiert wie bei Maven)
	- größere Konfigurationen können bei Bedarf in Form von eines Scala-Programms geschrieben werden (sbt wird dabie als Library verwendet)
- Dependency-Management mit Apache Ivy, so dass Libraries aus öffentlichen Artefakt-Repositories verwendet werden können (löst Abhängigkeiten auf und lädt die benötigten Ressourcen aus dem Internet herunter), Default von Maven Central, zusätzliche Repositories können per Konfiguration zugänglich gemacht werden
	- Ivy legt ein lokales Repository im Verzeichnis .ivy2 unter dem HOME-Verzeichnis des Benutzers an (bei Windows: C:\\Users\\Bob); hier werden Dateien aus Remote Repositories zwischengespeichert; lokal publizierte Artefakte landen ebenfalls hier
- kontinuierliche Builds und Tests (mit \texttt{\textasciitilde} als Präfix) - unmittelbares Feedback auf Änderungen, sehr nützlich
- unterstützt gemischte Java/Scala-Projekte
- interaktive Shell/Kommandozeile, unterstütz Tab-completing args to commands
- inkrementelle Kompilation

- sbt kann durch Plugins erweitert werden (z.B. Plugins, die automatisch Projekte für IDEs wie Eclipse oder IntelliJ erzeugen), dazu müssen Plugins in der Build-Definition angegeben werden

- Problematisch:
	- leichter Einstieg, aber für umfangreichere Konfigurationen ist ein tiefes Verständnis nötig -> gute Doku
	- Syntax
	- relativ neu im Verlgeich zu (Ant oder Maven) -> kleines aber wachsendes Ökosystem von Plugins

-->  \url{http://www.scala-sbt.org/}
-->  \url{https://en.wikipedia.org/wiki/SBT_%28software%29}
-->  \url{https://codeascraft.com/2014/09/30/building-a-better-build-our-transition-from-ant-to-sbt/}

Bsp. für Dependencies (-->  Website Knabe)
	libraryDependencies ++= Seq(
       //vendor % artifact % version % scope
       "junit" % "junit" % "4.8.1" % "test",
       //vendor %% scalaVersionDependentArtifact % ownVersion % scope
%       "org.scalatest" %% "scalatest" % "2.2.1" % "test"
    )
    "Dazu ist noch eine Erläuterung nötig. Da Scala agressiv weiterentwickelt wird, gibt es häufig inkompatible Versionsunterschiede zwischen einer Version x.y und x.(y+1), nicht aber zwischen x.y und x.y.z. Daher werden Scala-Libraries üblicherweise gegen eine bestimmte Scala-Version x.y kompiliert und es wird deren Nummer in den Artefaktnamen aufgenommen. All dies leistet der Operator \%\%. Der Operator \% nimmt hingegen den Artefaktnamen, so wie er im Buildfile angegeben ist. Er ist daher für die Benutzung von Java-Libraries meist der richtige."



























% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Vorstellung von Scala.js (5)}

%TODO einarbeiten, siehe 03_Scala.JS.txt



>> Was ist Scala.js?
-->  Doeraene: SJS. What has it become, Slide 17 %TODO Bild
-->  \url{https://jaxenter.com/interview-compiling-scala-to-javascript-with-scala-js-107247.html}

Scala.js ist ein Scala-Dialekt der nach JavaScript kompiliert.\cite[S. 1]{doeraene2013.TDI}

Entwickelt von Sébastien Doeraene seit Februar 2013 am EPFL (?) angeregt durch einen Vorschlag von Martin Odersky
- mittlerweile kleines Team von Mitarbeitern
\cite{doeraene2013.CSJ}


(
  -->  http://www.scala-lang.org/news/2015/02/05/scala-js-no-longer-experimental.html
  -->  http://www.heise.de/developer/meldung/Scala-js-bereit-fuer-produktiven-Einsatz-2542748.html
)
- Entwicklungsbeginn Februar 2013
- erstmalig vorgestellt bei den vierten Scala Days im Juni 2013
- erste Veröffentlichung mit Version 0.1 Ende 2013
- seit Februar 2015 mit Version 0.6.0 nicht mehr experimentell, bereit für den professionellen Einsatz
  - ab 0.6.0 rückwärtskompatibel:
    - Semantik
    - Standardbibliothek scala.scalajs.js (sowohl Quellcode-kompatibel als auch binärkompatibel)
    - sbt-Builds (Quellcode-kompatibel)
  - Zwischencode in .sjsir-Dateien (Scala.js-Pendant zu .class-Dateien der JVM)  
- Geschichte
-->  Doeraene: SJS. What has it become, Slide 6 ff.








>> andere Sprachen die nach JavaScript kompilieren, davon statisch getypt  -->  \url{https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-JS}
-> Doeraene-Paper
andere Ansätze/Sprachen, deren Defizite
 transpiled:
   Dart, CoffeeScript, TypeScript
 compiled:
   GWT (Google Web Toolkit), Opal (Rb 2 JS)
-> \url{https://en.wikipedia.org/wiki/JavaScript#Use_as_an_intermediate_language}

JavaScript wird schon bezeichnet als Assembler für das Internet ("`assembly language for the web"') bzw. Virtual Machine des Internets ("`VM of the web"', Douglas Crockford)
  -->  \url{http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx}
  --> \url{http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebPart2MadnessOrJustInsanity.aspx}
  - JavaScript ist eine Plattform\cite{doeraene2015.SSP}


\url{https://en.wikipedia.org/wiki/List_of_JavaScript_libraries}

\url{https://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks}


Liy Haoyi, Mitarbeiter beim Scala.js-Projekt und Autor des E-Books "`Hands-on Scala.js"' bringt die Motivation, für Scala.js auf den Punkt: "`At this point, all of Google, Facebook, and Microsoft have all announced work on a typed variant of Javascript. These are not academic exercises: Dart/AtScript/Flow/Typescript are all problems that solve a real need, that these large companies have all faced once they've grown beyond a certain size. Clearly, Javascript isn't cutting it anymore, and the convenience and "native-ness" of the language is more than made up for in the constant barrage of self-inflicted problems. Scala.js takes this idea and runs with it!"'\cite[\#TheLanguage]{haoyi.HOS}


Code-Wiederverwendung
- traditionell verschiedene Sprachen für Client (JavaScript) und Server (PHP, Java u.a.)
	\url{http://w3techs.com/technologies/overview/client_side_language/all}
	\url{http://w3techs.com/technologies/overview/programming_language/all}
	- in dem Fall:
		- Mehrfachimplementierung von Algorithmen
		- Ajax-Aufrufe um Logik an einem Ort zu halten
- eine Sprache auf Client und Server: mit Node.js JavaScript, aber mit allen beschriebenen Problemen von JS




Kern-Features:
- Scala-Support
- Typsicherheit
- JavaScript-Interoperabilität
- sbt-Integration
- IDE-Support
- Source Maps
- minimierter/optimierter Produktionscode
- Ökosystem: Libraries und Tools


\section{Scala-Support und semantische Unterschiede}

kompletter Scala-Support

...

aber nicht unterstützt:
- REPL
- reflection
- Java collections
- parallel collections
\cite{doeraene2013.CSJ}
- nur kleiner Teil der Java-Standardbibliothek unterstützt (Stand Juni 2014)\cite{doeraene2014.WHB}


semantische Unterschiede (vgl. \cite{doeraene2015.SSP} und \cite{scalajs.DSS}):
	- primitive Typen
	- undefiniertes Verhalten

primitive Typen: Zahlen-Semantik
	- abweichend für Float, da keine Entsprechung in JS (-> Doeraene-Paper):
    - strikte Float-Semantik kann, wenn benötigt, per sbt-Konfiguration erzwungen werden, kann aber massive Performance-Einbußen zur Folge haben
    - alle anderen numerischen Typen habne gleiche Semantik
    - Besonderheit: toString für Fließpunktkommazahlen:
    	- eine einzelne Null nach dem Komma wird verschluckt
    	- Floats werden wie Doubles behandelt und werden deshalb unschön ausgegeben:
    	println(1.4)  // -> 1.4
		println(1.4f) // -> 1.399999976158142
	- deshalb müssen sie passend formatiert werden, z.B.: \texttt{f\"\${1.4}\%.1f"}  --  Achtung: String.format funktioniert nicht, weil Java

semantische Unterschiede / "`The Performance/Correctness Tradeoff"' --> \cite[\#ThePerformance/CorrectnessTradeoff]{haoyi.HOS}
- Scala.js könnte näher an Scala-Semantik sein, aber Overhead
- Bsp. Division durch Null
\begin{lstlisting}
Problem:
	JVM: 15 / 4           // 3
	JS:  15 / 4           // 3.25
Fix:
	JVM: 15 / 4           // 3
	JS:  (15 / 4) | 0     // 3
neues Problem:
	JVM: 15 / 0           // ArithmeticException
	JS:  15 / 0           // Infinity
	JS:  (15 / 0) | 0     // 0
moeglicher Fix (aber teuer):
	JVM: 1 / 0           // ArithmeticException
	JS:  function intDivide(x, y){
  var z = x / y
  if (z == Infinity) throw new ArithmeticException("Divide by Zero")
 else return z
 }
 intDivide(1, 0) // ArithmeticException
\end{lstlisting}
	- wäre ineffizienter Fix, für jede Division statt zwei simpler arithmetischer Operation einen Funktionsaufruf und Prüfung auf Infinity zu ersetzen
	- Kompromiss von Scala.js: im FastOpt-Modus gibt es Prüfungen auf ArithmeticException,  ArrayIndexOutOfBoundsException usw. (aber noch work in progress); im FullOpt-Modus werden diese Prüfungen entfernt

- aus Performance-Gründen kein Boxing für primitive Typen (sie werden nicht in Objekttypen eingepackt, durch die sie als Int, Double, Float etc behandelt werden können) ->->
- Prüf-Methode isInstanceOf[T] (unter der Haube bei Pattern Matching verwendet) operiert (für primitive Werte) basierend auf dem Wert, nicht dem Typ
[Dublette]: - Typtests zur Laufzeit sind wertbasiert, also z.B.: 1 matched Byte, Short, Int, Float und Double, 1.5 matched Float und Double, 1.4 matched Double (da es nicht als 32-bit Float repräsentiert werden kann)


- undefiniertes Verhalten
	- unkorrekte Typen casten ist ein Bug
		Bsp.:
\begin{lstlisting}[language=Scala]
val s = "foo"
s.asInstanceOf[List[String]]
\end{lstlisting}
	- JVM wirft ClassCastException
\begin{lstlisting}
java.lang.ClassCastException: java.lang.String cannot be cast to scala.collection.immutable.List
\end{lstlisting}
	- zu großer Overhead für Checks in JavaScript (Laufzeittypprüfungen würden Ausfführungszeit verdoppeln) -> undefiniertes Verhalten (alles kann passieren)
	- dev mode (fastOpt) mit checks -> direkter Absturz für Debugbarkeit
\begin{lstlisting}
scala.scalajs.runtime.UndefinedBehaviorError: An undefined behavior was detected: hello is not an instance of scala.collection.immutable.List
\end{lstlisting}
		- Achtung: kein Hinweis auf den fehlgeschlagenen Cast
	- prod mode (fullOpt) ohne checks für Performance (Casts werden weg-optimiert und sind eine Nicht-Operation/no-op), aber: unvorhersagbares Verhalten
	- JVM-konformes Verhalten mit dem Werfen von ClassCastExceptions kann erzwungen werden, aber wie gesagt mit hohen Performance-Einbußen
	
	- auch undefiniert:
		NullPointerException
		StackOverflowError und andere VirtualMachineErrors
		
		ArrayIndexOutOfBoundException
		StringIndexOutOfBoundException
		ArrayStoreException
		ArithmeticException
		- diese vier werden in der Zukunft einmal Fatal/Unchecked/Compliant Einstellungen haben
		- z.B. "foo".charAt(-1) //  wirft eine "`fatal"' scala.scalajs.runtime.UndefinedBehaviorError und beendet das Programm (im fastOpt-Modus)
	- weitere Details -> gut dokumentiert in Doku
	
	
	- ansonsten Semantik von Scala.js Programmen wie Scala!





\section{Typsicherheit}

garantierte Typsicherheit durch Compiler-Prüfungen:
- Fehler wie: foo is not a function können nicht mehr auftreten, wenn einer Variablen, die etwa eine function erwartet auch nur eine solche zugewiesen werden kann

...




\section{JavaScript-Interoperabilität}

- "`Typbestimmte"' JavaScript-Interoperabilität
-->  \url{http://www.scala-js.org/doc/js-interoperability.html}
-->  \cite{doeraene2013.TDI}

Interop
- abstrakte Fassaden für JS-Code
- undefined behaviour


> Typkorrespondenzen: "`primitive"' Scala-Typen sind primitive JavaScript-Typen\cite{doeraene2014.WHB} (<- auch Quelle für Tabellendaten):
%siehe auch -->  \url{http://www.sebnozzi.com/229/pass-simple-values-js-functions/}

\medskip

\begin{tabular}{|l|l|}
\hline \textbf{Scala} & \textbf{JavaScript} \\ 
\hline \texttt{Float}, \texttt{Double} & \texttt{Number} \\ 
\hline \texttt{Byte}, \texttt{Short}, \texttt{Int} & \texttt{Number} (mit beschränktem Gültigkeitsintervall) \\ 
\hline \texttt{String} & \texttt{String} \\ 
\hline \texttt{Null} & \texttt{null} \\ 
\hline \texttt{Unit} & \texttt{undefined} \\ 
\hline \texttt{Subtypen von js.Object} & der entsprechende JavaScript-Typ \\ 
\hline \texttt{Char} und \texttt{Long} & opak \\ 
\hline alle anderen Typen & opak, außer explizit exportierten Membern \\ 
\hline 
\end{tabular}

\medskip

diese Typen werden direkt entsptrechend dieser Korrespondenz übersetzt


- es gibt auch Nicht-Korrespondenzen:

ein Scala-Function "`ist"' keine JavaScript-Function, dafür existieren implizite Konvertierungen (in beide Richtungen) und Typen js.Function-Typen


js.Array[T] <--> mutable.Seq[T]
js.Dictionary[T] <--> mutable.Map[String, T]
js.UndefOr[T] <--> Option[T]

Ein js.Array kann direkt dem korrespondierenden Scala-Typ zugewiesen werden

val jsArr = js.Array(1, 2, 3)
val x: mutable.Seq[Int] = jsArr

für die Rückrichtung existieren implizite Methoden und Wrapper-Klassen zur Konvertierung, dazu Import

import js.JSConverters.\_
val jsArray: js.Array[Int] = Seq(1, 2, 3).toJSArray

der Mechanismus für js.Dictionary und js.UndefOr ist ähnlich



> JavaScript von Scala.js aus aufrufen

wichtigste Richtung der Interop

primitive JS-Typen entsprechend Korrespondenz (-> Tabelle) repräsentiert

für andere vordefinierte JavaScript-Typen existieren es Definitionen in scala.scalajs.js:

\begin{lstlisting}
js.Any
 +- js.Object
 |   +- js.Date
 |   +- js.RegExp
 |   +- js.Array[A]
 |   +- js.Function
 |       +- js.Function0[+R]
 |       +- js.Function1[-T1, +R]
 |       +- ...
 |       +- js.Function22[-T1, ..., -T22, +R]
 |       +- js.ThisFunction
 |           +- js.ThisFunction0[-T0, +R]
 |           +- js.ThisFunction1[-T0, -T1, +R]
 |           +- ...
 |           +- js.ThisFunction21[-T0, ..., -T21, +R]
 +- js.Dictionary[A]
\end{lstlisting}
-->  \url{http://www.scala-js.org/doc/calling-javascript.html}


Funktionen
	js.Function
	js.ThisFunction für Funktionen, die das Verhalten von this in JavaScript modellieren, indem ihnen als erster Parameter das this-Argument, also der Aufrufkontext, übergeben wird

JavaScript-Objekte können als Literale erzeugt werden:

dieser Scala.js-Code:
\begin{lstlisting}[language=Scala]
js.Dynamic.literal(foo = 42, bar = "foobar")
\end{lstlisting}

entspricht in JavaScript:
\begin{lstlisting}[language=JavaScript]
{foo: 42, bar: "foobar"}
\end{lstlisting}


Integration von JavaScript-APIs
- durch Fassaden Verwendung von JavaScript-APIs wie (wichtig!) den DOM oder auch jQuery, ganz normaler Aufruf wie Scala-Code
	- dazu existieren Libraries
	- eigene Fassaden können bei Bedarf geschrieben werden
		Fassaden (Bsp. nach \cite{doeraene2015.SSP}):

\begin{lstlisting}[language=Scala]
// es existiert:
trait js.Any extends scala.AnyRef

// dann Fassade (vereinfacht):
@js.native // Annotation fuer Vorwaerts-Kompatibilitaet mit Scala.js 1.0.0
class XMLHttpRequest extends /*...*/ js.Object {
  def status: Int = js.native
  def responseText: String = js.native
  var onload: js.Function1[Event, _] = js.native
  def open(method: String, url: String, async: Boolean = js.native, ...): Unit = js.native
  def send(data: js.Any = js.native): Unit = js.native
}

// kann nun verwendet werden:
def main(pre: html.Pre): Unit = {
  val xhr = new dom.XMLHttpRequest()
  xhr.open("GET",
    "http://api.openweathermap.org/" +
    "data/2.5/weather?q=Singapore")
  xhr.onload = { (e: dom.Event) =>
    if (xhr.status = 200)
      pre.textContent = xhr.responseText
  }
  xhr.send()
}

// TODO: dynamische Variante -> Doeraene-Folie ******
\end{lstlisting}
- Typen wie Int oder String können normal mit Scala-Sematik verwerdet werden, obwohl hinter der Kulissen JavaScript sind (durch implizite Konvertierung durch Scala.js)


- Werte die von Fassaden-Typen geliefert werden, werden vom Compiler systematisch entsprechend ihrer Signatur gecastet, d.h. ihr Typ ist danach bekannt

\begin{lstlisting}[language=Scala]
class Foo extends js.Any {
  def bar: Boolean = js.native
}

val foo = new Foo

val baz = foo.bar
\end{lstlisting}

- dadurch, dass der Typ nach diesem Cast als bekannt angenommen wird, kann Scala.js-Code bei der Übersetzung optimiert werden
- d.h. aber auch: wenn die eigentliche JavaScript-Implementierung kein Boolean zurückgibt -> undefiniertes Verhalten (keine Exception)
\cite{doeraene2015.SSP}



- wenn möglich, vermeiden, aber manchmal ist es vielleicht nötig, nach JavaScript-artig, dynamisch zu typisieren, typischerweise um auf JavaScript-API zuzugreifen, für die noch keine Scala.js-Fassade existiert: ->
- nahezu JavaScript in Scala schreiben möglich mit: dynamischer Zugriff auf JavaScript über dynamisch typisierte Referenz auf den globalen Scope mit js.Dynamic.global vom Typ js.Dynamic:
\begin{lstlisting}[language=Scala]
val doc = js.Dynamic.global.document
val foo = doc.getElementById("foo")
val div = document.createElement("div")
\end{lstlisting}
dabei sind doc, foo und div vom Typ js.Dynamic, der von js.Any erbt


Instanzen von dynamischen Typen können auch erzeugt werden:
\begin{lstlisting}[language=Scala]
val today = js.Dynamic.newInstance(js.Dynamic.global.Date)()
\end{lstlisting}



> Scala.js nach JavaScript exportieren
	-->  \url{http://www.scala-js.org/doc/export-to-javascript.html}

Export nach JS mit Annotationen
- oft genügt:
\begin{lstlisting}[language=Scala]
object MyApp extends scala.scalajs.js.JSApp {
  def main(): Unit = {
  	/* ... */
  }
}
\end{lstlisting}
	- damit MyApp und main exportiert
- @JSExport
	- Überladen von Methoden mit gleichem Namen und unterschiedlicher Signatur möglich
- toString standardmäßig exportiert
- mehr siehe Doku









\section{sbt-Integration}

(http://www.scala-lang.org/news/2015/02/05/scala-js-no-longer-experimental.html)

sbt-Plugin
  - compiling, running, linking, optimizing --> http://www.scala-js.org/doc/sbt-plugin.html
  - als Test-Runner - mit Rhino, Node.js oder PhantomJS

command line interface (CLI)
  - Scala.js ohne sbt  -->  http://www.scala-js.org/downloads.html



in
\begin{lstlisting}
enablePlugins(ScalaJSPlugin)
\end{lstlisting}

\begin{lstlisting}
libraryDependencies += "org.scala-js" %%% "scalajs-dom" % "0.8.0"
\end{lstlisting}

\begin{lstlisting}
libraryDependencies ++= Seq(
  "org.scala-js" %%% "scalajs-dom" % "0.8.0",
  "com.lihaoyi" %%% "scalatags" % "0.5.2"
)
\end{lstlisting}










% % % % % % % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % % % % % % %





>>Projekt anlegen

%-->  \url{http://www.scala-js.org/doc/tutorial.html}

Ordnerstruktur anlegen wie folgt

TODO: Ordner-Struktur

leider nicht automatisch, es gibt (angeblich?) Plugins (???), eigenes Skript schreiben (-> Datenträger)
	- ein Weg mit IntelliJ (zu spät entdeckt): sbt-Projekt erzeugen, generiert Standard-Ordnerstruktur (inkl. leerer Java Verzeichnisse), erzeugt build.sbt, plugins.sbt und build.properties, die angepasst werden können


Scala.js-sbt-Plugin hinzufügen

Im Ordner \texttt{project} eine Datei \texttt{plugins.sbt} erzeugen:
\lstinputlisting[language=Scala, caption={Eine minimale plugins.sbt.}]{listings/setup/minimal_plugins.sbt}

Im Basisordner des Projekts eine Datei \texttt{build.sbt} zur Build-Definition erzeugen:
\lstinputlisting[language=Scala, caption={Eine minimale build.sbt.}]{listings/setup/minimal_build.sbt}

Hier wird das Plugin aktiviert
Name und Versionsnummer für das Projekt festgelegt
Scala-Version festlegen, muss mindestens 2.10.2 sein

mit scalaJSStage in Global := FastOptStage wird Node.js als JavaScript Runtime / Interpreter (für JS von der Kommandozeile run und test) aktiviert (statt dem langsameren Default: Rhino); Node.js muss installiert sein;

\lstinputlisting[language=Scala, caption={Eine minimale build.properties.}]{listings/setup/minimal_build.properties}
sbt-Version festlegen, muss mindestens 0.13.7 sein


strengere Compilerprüfungen durch: ...


-- build.sbt - Dependencies --

für JS-Libraries:
SalaJSKeys.jsDependencies += "org.webjars" % "jquery" % "2.1.4" / "jquery.js"

wenn es ein getyptes Interface gibt (wie für jQuery der Fall), dann genügt (webjars werden transitiv referenziert):
libraryDependencies += "be.doeraene" %%% "scalajs-jquery" % "0.8.0"

Einbindung in HTML mit einem script-Tag möglich durch:
skip in packageJSDependencies := false
FRAGE: ist das noch nötig, oder geschieht das schon automatisch?

dann in der HTML:
<script src="projectname-jsdeps.js"></script>












% % % % % % % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % % % % % % %























\section{IDE-Support}
(http://www.scala-lang.org/news/2015/02/05/scala-js-no-longer-experimental.html)

IDE-Supports
  "With Scala.js tooling, you get syntax highlighting, code completion (even for JavaScript libraries and the DOM!), jump-to-definition, and most other features you come to expect in a Scala tooling environment" (http://www.scala-lang.org/news/2015/02/05/scala-js-no-longer-experimental.html)

  - IntelliJ IDEA  -->  https://www.jetbrains.com/idea/help/getting-started-with-scala-js.html

    Zum komfortablen Editieren und von Scala.js-Projekten
    - Code-Inspection: schlägt automatisch Scala-Code-Verbesserungen
    - Typ-Inferenz: Alt + Enter - für automatische Typ-Annotation einer Variablendefinition (Bsp. val xs = List("a", "b") wird zu val xs: List[String] = List("a", "b"))

    auch für JavaScript, HTML, CSS (in der Ultimate Edition, free für edu und open source)
      - Syntax-Highlighting
      - Code-Completion und Source-Docs zu vielen Schlüsselworten, zu JS-Standard-APIs wie DOM-API
      - jump to definition
      - intelligentes Namens-Refactoring (zumindest innerhalb einer Datei)


\section{Source Maps}

Source Maps (zum Debuggen im Browser)  -->  http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/

Source Maps
  - Debugging im Browser
  http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/

Dokumentation
  - Website
  - API-Docs
  - Einstieg
    - Tutorial
    - E-Book: Hands-on Scala.js
    - Scala.jsFiddle

--> Bsp. helloscalajs in Fallstudien


\section{minimierter/optimierter Produktionscode}
\label{sec:compiler}

>> sbt-Konfiguration und "`Compilation und Optimization Pipeline"'

(mit Google Closure Compiler  -->  https://developers.google.com/closure/compiler/)

...


-- sbt-Kommandos --

Infos hier geben tieferen Einblick scheinen aber nicht auf dem aktuellsten Stand zu sein.
\url{http://www.scala-js.org/doc/internals/compile-opt-pipeline.html}

\cite[\#TheCommandLine]{haoyi.HOS} ist hier wieder eine wertvolle und (als Mitarbeiter des Projekts) auch autorisierte Quelle -> es gibt weiter unten ein Kapitel "`The Command Line"' zum Thema.

\texttt{set scalaJSStage in Global := FastOptStage}

\texttt{set scalaJSStage in Global := FullOptStage}


\texttt{fastOptJS // = dev} kompiliert und optimiert (schnellerer Compiler-Lauf, größere Datei) - zur Entwicklung

\texttt{fullOptJS // = prod} kompiliert und optimiert (langsamerer Compiler-Lauf, aggressiver optimiert -> kleinere Datei, schnelleres JS) - zur Auslieferung

mit vorangestellter  \texttt{\textasciitilde{}}, z.B. \texttt{\textasciitilde{}fastOptJS}

\texttt{run} kompilierte Scala.js-Anwendung in einer JavaScript Laufzeit/VM (Rhino, Node.js oder PhantomJS) ausführen (main-Methode wird benötigt wie in -> Hallo-Welt)
	- läuft per default in der \textit{PreLinkStage}, verwendet Rhino
		- für DOM-API: mit \texttt{jsDependencies += RuntimeDOM} in der \texttt{build.sbt} wird die DOM-API in Rhino emuliert
	- schnellere Laufzeit (Node.js oder PhantomJS) durch \texttt{scalaJSStage in Global := FastOptStage} in der Build-Definition oder \texttt{set scalaJSStage in Global := FastOptStage} in der sbt-REPL (oder FullOptStage) aktiviert, standardmäßig Node.js
		- für DOM-API: \texttt{jsDependencies += RuntimeDOM} aktiviert PhantomJS (langsamer als Node.js)

\texttt{test} kompilierte Scala.js-Tests im \texttt{tests/}-Verzeichnis auf Rhino, Node.js oder PhantomJS ausführen
	- erzeugt im Verzeichnis \texttt{target/test-reports/} Test-Reports in XML-Form

\texttt{compile} kompiliert zu Scala.js Bytecode

\texttt{package} Scala.js-Anwendung als .jar-Datei packen (z.B. \texttt{hello-scalajs\_sjs0.6\_2.11-1.0.jar} mit Suffix: Scala.js-Version, Scala-Version, Projekt-Version)






Das Kommando \texttt{sbt fastOptJS} (bzw. \texttt{sbt fullOptJS}) erzeugt Dateien im Ordner
%target/scala-2.11/classes/  -- .class und .sjsir >> nicht benötigt (Output des Scala.js-Compilers: Scala/JVM-Bytecode und Scala.js-Bytecode/Zwischencode)
%target/scala-2.11/classes/  --  html << benötigt
%target/scala-2.11/  --  js << benötigt












>> hinter der Fassade / Interna

getypte Fassade vs. js.Dynamic
- Vergleich
- asInstanceOf[T]
  - Typsicherheit
  - Performance: Compiler-Optimizer kann optimieren

...






>> was ist neu
  -->  http://www.scala-js.org/news/2015/08/31/announcing-scalajs-0.6.5/
  -->  http://www.scala-js.org/doc/sjs-defined-js-classes.html






\section{Ökosystem: Libraries und Tools}

>> verwendete/ausprobierte/untersuchte Libraries (2)

\subsubsection{Scala-js-dom}

- statische Typen für die DOM-API, Erweiterungen

http://scala-js.github.io/scala-js-dom/
scalajs.dom.ext.Color

\subsubsection{(scala-js-jquery)}

- statische Typen für jQuery)

\subsubsection{ScalaTags}

- cross-kompilierende HTML-Templating-Library (mehr Typsicherheit für Tags)

Motivation
%  -->  http://lihaoyi.github.io/scalatags/#WhyScalatags
%  -->  http://lihaoyi.github.io/scalatags/#PriorWork



mit \texttt{\`{}TypedTag[html.Element].render\`} wird eine DOM-Tree-Node erzeugt
  val foo = div("`foo"').render
  assert(foo.textContent == "foo")
  foo.text
  assert(foo.textContent == "foo")
%  --> http://lihaoyi.github.io/scalatags/#UsingtheDOM

erlaubt direkten Zugriff auf referenzierte Elemente ohne Suche im DOM mit DOM-Selektoren (mit document.getElementById(...) bzw. jQuery)
%  -->  http://lihaoyi.github.io/scalatags/#UseCases

ScalaTags: importe / Bundles - schwer zu verstehen, am einfachsten JsDom.all\_, aber dann clutter im Namespace

CSS/Style - wenn nötig können Attribute und Styles in Variablen gemerkt werden; auf diese Weise können auch eigene Attribute festgelegt werden, die Scalatags nicht kennt:
%  val dataAppKey = "data-app-key".attr
%  val customBackgroundStyle = "background-color".style
%  div(
%    dataAppKey:="YOUR_APP_KEY",
%    customBackgroundStyle:="red"
%  )

(CSS mit Vererbung
%  -->  http://lihaoyi.github.io/scalatags/#CSSStylesheets)

Vertiefung
%  -->  http://lihaoyi.github.io/scalatags/#Internals


\subsubsection{utest}

- minimale cross-kompilierende Test-Library


\subsubsection{(uPickle)}

- cross-kompilierende Library zur Serialisierung)


\subsubsection{autowire}

- cross-kompilierende Library für statisch getypte Ajax-Aufrufe und RPCs

\subsubsection{(spray)}

- Sammlung von Libraries zur Entwicklung von REST/HTTP-basierten Webservices auf der Basis von Akka; beinhaltet spray-can, einen schnellen HTTP-Server)

\subsubsection{(Scala.Rx)}

- cross-kompilierende Change-Propagation-Library ("Änderungsausbreitung"))

\subsubsection{Scala-Async}

- Scala-Library zur einfacheren Handhabung von Asynchronität; funktioniert mit Scala.js -->  http://docs.scala-lang.org/sips/pending/async.html

\subsubsection{Scala.js workbench}

- sbt-Plugin zum automatischen Live-Neuladen des Browsers


Check: alle Infos up-to-date?
-->  http://www.scala-js.org/news/2015/02/05/announcing-scalajs-0.6.0/
-->  http://www.scala-js.org/news/2015/08/31/announcing-scalajs-0.6.5/





% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Methodik}

>>Ziele

Verwendungsweise(?) - wie funktioniert es in der Anwendung
Konfiguration
	wie?
	Aufwand
Performance
	Build: Compiler, Tests
Wartbarkeit, Entwicklerfreundlichkeit
	Debugging-Qualitäten
	Code-Qualität
	Entwicklungsgeschwindigkeit (?)
	Dokumentation
Nützlichkeit: Umsetzbarkeit von Anforderungen der Web-Entwicklung
	DOM
	Events
	Canvas
	AJAX

\section{Kriterien der Evaluierung}

%\subsection{anwenderbezogen}
%
%Anforderungen an interaktive Webseiten
%- schnell laden
%- Interaktionen sollen sich schnell anfühlen
%- sollen regelmäßig weiterentwickelt werden
%
%\subsubsection{Korrektheit}
%\subsubsection{Performance}
%\paragraph{Seitenladezeit}
%\paragraph{Speicherbedarf/"`Page weight"'}
%\paragraph{Ausführungszeit von Funktionen}
%\paragraph{(Speicherbelastung)}
%\paragraph{(CPU-Belastung)}
%
%\subsection{entwicklerbezogen}
%
%TODO Antworten ins Kapitel "`Auswertung ..."'
%
%Anforderungen an Entwicklungswerkzeuge
%- siehe \url{http://www.scala-js.org/doc/cookbook/}
%- ...
%- Kompatibilität:
%  - siehe Doeraene: SJS. What has it become, 19:00  -->  \url{https://www.parleys.com/tutorial/scala-js-what-has-become-how-used-wild}
%Dokumentation:
%	- offizielle Referenzseite
%	  - API-Doku - vollständig (?) aber knapp
%	  - Tutorial
%	- Hands-on Scala
%???:
%	- Scala-Js-Fiddle  -->  http://www.scala-js-fiddle.com/
%Tests:
%	- utest - für JVM und JS
%
%\subsection{Code-Qualität}
%\paragraph{Typsicherheit}
%\paragraph{LOC (Lines of Code)}
%\paragraph{Komplexität}
%\paragraph{Lesbarkeit/Verständlichkeit}
%\paragraph{"`Debugbarkeit"'/Wartbarkeit, Erweiterbarkeit, Wiederverwendbarkeit}
%
%\subsection{JavaScript-Interoperabilität}
%
%\subsection{Konfiguarationsaufwand}
%
%\subsection{alles umsetzbar? Grenzen? alle Anwendungsfälle abgedeckt?}
%
%\subsection{Dokumentation}
%
%\subsection{Unterstützung durch Tools, Entwicklungsgeschwindigkeit}
%
%\subsection{Support/Fachforen etc.}
%
%
%\section{Gewählte Testverfahren und -techniken}
%
%\subsection{m01 - Vergleichs-Implementierung in reinem JavaScript/HTML}
%\subsection{m02 - HTML-Validierung}
%\subsection{m03 - Unit-Tests mit Jasmine (für Vergleich Scala.js/JavaScript)}
%\subsection{m04 - Unit-Tests mit utest}
%\subsection{m05 - Seitenladezeit messen mit Webpagetest und YSlow}
%\subsection{m06 - Profiling mit Chrome Developer Tools}
%\subsection{m07 - Benchmarks mit JSLitmus und Benchmark.js}
%\subsection{m08 - Halstead-Metrik}
%\subsection{m09 - Anzahl zusätzlicher Library-Dependencies}
%\subsection{m10 - empirische/experimentell}

\section{Vorgehensweise bei der Untersuchung}

%Matrix - welche Methode für welche Kriterien


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Projekt-Setup, Installation}

%TODO (Abweichungen ggf. separat bei der jeweiligen Anwendung)

Die nachfolgende Anleitung bezieht sich auf die Installation auf einem Windows-8.1-Rechner. Auf anderen Plattform können einzelne Schritte im Detail abweichen.

Um die Installation erfolgreich durchführen zu können ist eine gute Internetverbindung erforderlich, da die einige Bibliotheken heruntergeladen müssen. Außerdem wird ein aktueller Browser benötigt. Für volle \textit{Sourcemaps}-Unterstützung in der Browser-Konsole empfiehlt sich hier Google Chrome\footnote{\url{https://www.google.de/chrome/browser/desktop/}}.

Die folgende Software wird benötigt:

\begin{itemize}
	\item Java Development Kit (JDK) 8\footnote{ggf. genügt auch ein JRE}  --  \url{www.oracle.com/technetwork/java/javase/}
	\item Scala  --  \url{http://www.scala-lang.org/}
	\item sbt  --  \url{http://www.scala-sbt.org/}
	\item git  --  \url{https://git-scm.com/}
	\item Node.js  --  \url{https://nodejs.org/en/}
	\item PhantomJS  --  \url{http://phantomjs.org/}
\end{itemize}

Alle benötigten Programme sind auf dem beigefügten Datenträger enthalten, lassen sich alternativ auch unter der angegebenen Adresse beim Hersteller herunterladen. Bei Bedarf finden sich dort auch Installationsanleitungen, die allerdings nicht benötigt werden sollten. Für Windows existieren ausführbare Installationsprogramme, die selbsterklärend sind. PhantomJS muss nicht installiert werden; hier genügt es, den Inhalt der .zip-Datei ins gewünschte Programmverzeichnis zu entpacken.

Für alle Programme mit Ausnahme von git ist es unter Windows nötig, dem System den Installationspfad bekannt zu machen. Dies geschieht durch Setzen einer entsprechenden Umgebungsvariablen. Dazu muss der "`System"'-Dialog geöffnet werden, zum Beispiel durch die Tastenkombination \texttt{Windows-Taste + x}. Hier "`Erweiterte Systemeigenschaften"' mit Administrator-Rechten öffnen und die folgende Frage, ob Änderungen am System zugelassen werden sollen mit "`Ja"' bestätigen. Nun den Knopf "`Umgebungsvariablen"' betätigen, die Variable "`Path"' auswählen und auf "`Bearbeiten..."' klicken. Hier muss nun der Pfad der die ausführbare Datei für das entsprechende Programm enthält angegeben werden. Das ist für alle benötigten Programme mit Ausnahme von Node.js der Ordner \texttt{bin} im jeweiligen Programmverzeichnis. Dieser Pfad muss nun mit getrennt durch ein vorangestelltes Semikolon hinten an den ursprünglichen Wert angehängt werden. Für Java muss zum Beispiel \texttt{;C:\textbackslash{}Program Files\textbackslash{}Java\textbackslash{}jdk1.8.0\_51\textbackslash{}bin} angehängt werden.

Als Terminal wurde die git-bash vewendet, die in der Windows-Distribution von git enthalten ist. Alternativ kann auch die bash-Emulation von cygwin verwendet werden. Wenn IntelliJ IDEA verwendet wird, kann auch direkt von dort aus mit dem Terminal gearbeitet werden\footnote{\url{https://www.jetbrains.com/idea/help/working-with-embedded-local-terminal.html}}.

Scala.js muss nicht installiert werden sondern wird durch per Build-Definition als sbt-Plugin gestartet.

Für die bequemere Navigation im Projekt bietet sich der Einsatz IDE an. Infrage kommen:

\begin{description}
	\item[IntelliJ IDEA] liefert am meisten Komfort, unterstützt sbt schon am besten und ist deshalb klar die erste Wahl. Scala wird bei der aktuellen Version von Hause aus unterstützt, ältere Versionen lassen sich mit einem Plugin nachrüsten.
	\item[Scala IDE / Eclipse] funktioniert recht gut. Allerdings fehlt sbt-Unterstützung.
	\item[Netbeans] kommt ebenfalls in Betracht, wurde allerdings nicht erprobt. Hierfür existiert ein Scala-Plugin.
\end{description}


(Scala IDE oder/und  installieren; IntelliJ unterstütz Scala, für ältere Versionen Scala Plugin installieren)
(Google Chrome installieren - hat Sourcemaps-Unterstützung)



\section{IDE-Integration}

== in IntelliJ importieren ==

momentan komfortabler, sowohl Import als auch IDE-Support
	- bessere Integration mit sbt

- 1. IntelliJ > File > New > Project from Existing Sources...
- 2. Ordner auswählen
- 3. OK
- 4. Import project from external model > SBT
- 5. Next
- 6. check: Download sources and docs - wenn versucht werden soll, die Quellen der Library-Dependencies herunterzuladen
- 7. Finish

File > New > Project from Existing Sources...
alternativ: Welcome > Import Project
Select File or Directory to Import -- Projektordner (der build.sbt enthält) auswählen -- Ok
Import Project -- "Import project from external model" auswählen -- SBT auswählen -- Next
Import Project -- "Download sources and docs" auswählen -- Finish

Es ist auch möglich, mit sbt ein eine 


\begin{figure}[!h]
    \centering
    \includegraphics[
    width=0.25\linewidth
%   scale=0.5
    ]{tux}
    \caption{Eine Beispielabbildung.
    (Quelle: \cite{aab.FBB})
    }
    \label{fig:a_picture_of_tux}
\end{figure}

Änderungen an sbt-Konfigurationsdateien werden von IntelliJ erkannt; das Programm schlägt einen "Refresh" vor, der ausgeführt werden sollte
erkennt sbt-Dateien und unterstützt automatische Vervollständigung


== in Scala IDE importieren ==

Plugin: sbteclipse\footnote{\url{https://github.com/typesafehub/sbteclipse}}

dieses erzeugt ein Eclipse-Projekt

in project/plugins.sbt hinzufügen:
\begin{lstlisting}[language=Scala]
addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % "4.0.0")
\end{lstlisting}

wenn sbteclipse versuchen soll, die Quellen der Library-Dependencies herunterzuladen - in build.sbt hinzufügen:

\begin{lstlisting}[language=Scala]
EclipseKeys.withSource := true
\end{lstlisting}



- 1. run:
  sbt eclipse  --  .project und .classpath erzeugt, kann nun importiert werden
- 2. Scala IDE > File > Import > Existing Projects into Workspace
- 3. Ordner auswählen
- 4. Finish


Eclipse erzeugt standardmäßig einen Verzeichnis bin im Projektwurzelverzeichnis, als Zielordner des Compilers ...

nach Änderungen an sbt-Konfigurationsdateien ist es nötig, erneut \texttt{sbt eclipse} auszuführen und das Projekt in Eclipse im Package Explorer zu aktualisieren.






\section{Konfiguration von Node.js (und Karma?), source-map-support}

Node.js ...

Damit Stacktraces richtig aufgelöst werden sollte \textit{source-map-support}\footnote{\url{https://www.npmjs.com/package/source-map-support}} im Projekt installiert werden mit:

\begin{lstlisting}
npm install source-map-support
\end{lstlisting}

Die Dateien des Plugins werden im Projektverzeichnis in einem frisch erzeugten Ordner \texttt{node\_modules} abgelegt.

Es ist auch möglich, das Projekt als Node.js-Projekt zu initialisieren. Das hat den Vorteil, dass man sich die benötigte Dependency in einer Konfigurationsdatei merken kann.

\begin{lstlisting}
npm -y init
npm install source-map-support --save-dev
\end{lstlisting}

Künftig kann der \texttt{node\_modules}-Ordner bedenkenlos gelöscht werden. Ein einfacher Aufruf von \texttt{npm install} genügt um alle benötigten Node.js-Pakete zu laden.


\section{Installation und Start von Anwendung und Tests}

- Sourcen von Datenträger oder github(?) (-> git client), hierzu genügt der Aufruf git clone <repo> vom Terminal im gewünschten Verzeichnis
- Kommandos zum kompilieren --> sbt-Abschnitt - hierher???
- Readme für jedes Projekt mit ggf. abweichenden spezifischen Anweisungen zum Start der jeweiligen Anwendung


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Fallstudien (20)}

bei den Eingangsbeispielen gestützt auf
-->  Scala.js-Tutorial

wichtige Quelle
-->  Hands-on Scala.js


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Hello Scala.js: Ein Minimalbeispiel}

%lose orientiert an  -->  http://www.scala-js.org/doc/tutorial.html

%TODO jeweils die folgenden \\sections:
%
%\section{Beschreibung und Anforderungen}
%
%\section{Implementierung}
%
%\section{angewendete Testmethoden und Testergebnisse}
%
%\section{Beurteilung hinsichtlich der Evaluierungskriterien}

\subsection{Ziel der Untersuchung}

Ein minimales Setup in Form eines klassischen Hallo-Welt-Programms sollte zum Laufen gebracht werden. Anhand dieses Minimalbeispiels sollten dann bestimmte Grundbedingungen der Entwicklung mit Scala.js untersucht werden. Neben der Konfiguration selbst sollte als wichtiger Faktor für die alltägliche Entwicklungsarbeit die Zeit ermittelt werden, die für einen Build-Lauf benötigt wird. Auch die Größe der für die Auslieferung relevanten Kompilate sollte betrachtet werden, schließlich besteht ein unmittelbarer Zusammenhang zwischen der Größe der zu ladenden Datenmenge und der Ladezeit im Browser, weshalb sie eine wichtige Grundbedingung für die Zufriedenheit der Benutzer ist.
Außerdem sollte von der Sourcemap-Unterstützung Gebrauch gemacht werden und der ... HIER WEITER

hello-scalajs2:
In einer Erweiterung dieses Minimal-Beispiels, sollte eine Ausgabe ins Browser-Fenster gemacht werden. Zusätzlich sollte Benutzerinteraktion mit der Oberfläche mittels Buttons probiert werden. Als Reaktion auf Betätigung des einen Buttons sollte eine Ausgabe auf die Browser-Konsole, beim anderen eine Textänderung im Browser-Fenster erfolgen. Schließlich sollte die Testbarkeit solcher Oberflächen-Elemente geklärt werden.

hello-scalajs2:
Hallo Welt im Browser-Fenster
Interaktion im Browser-Fenster
Möglichkeit von Tests
Verwendung von jQuery (für Tests)
Dateigröße
Turnaround-Zeiten (=Durchlauf-Zeiten)


\subsection{Kriterien der Untersuchung}

\begin{enumerate}
	\item Konfigurationsaufwand
	\item Performance
	\begin{enumerate}
		\item Compiler-Geschwindigkeit
		\item Größe der Kompilate
	\end{enumerate}
	\item Wartbarkeit: 
		\begin{enumerate}
			\item Debugging-Qualitäten
			\item Testbarkeit
		\end{enumerate}
\end{enumerate}

\subsection{Kurzbeschreibung des Beispielprogramms}

Das minimale Programm erzeugt die Ausgabe "`Hello world!"' in der Konsole des Browsers, wenn die entsprechende Webseite geöffnet wird. Der Aufruf \texttt{sbt run} erzeugt die gleiche Ausgabe in der sbt-REPL.

Der benötigte Scala-Code ist überschaubar, wie Listing \ref{code:hello.scala} zeigt.

\lstinputlisting[language=Scala, caption={Scala.js-Code für ein Hallo-Welt-Programm.}, label={code:hello.scala}]{listings/01hello-scalajs/HelloApp.scala}

\texttt{HelloApp} erbt vom Trait \texttt{JSApp}, der eine \texttt{main}-Methode mit Rückgabetyp \texttt{Unit} verlangt. Dadurch kann die \texttt{HelloApp} mit ihrer \texttt{main}-Methode nun in JavaScript unter ihrem voll qualifizierten Namen verwendet werden. Die Methode \texttt{println} benutzt die Standardausgabe. Wenn das Programm in der sbt-REPL ausgeführt wird ist es die Konsole dort, im Browser wird die Browser-Konsole verwendet.

Dieses Programm lässt sich bereits auf der sbt-Konsole ausführen (Listing \ref{code:run-hello}).

\begin{lstlisting}[caption={Lauf des Hallo-Welt-Programms in der sbt-REPL.}, label={code:run-hello}]
$ sbt
> run
[...]
[info] Updating {[...]/hello-scalajs/}hello-scalajs...
[info] Resolving [...] ...
[info] Done updating.
[info] Compiling 1 Scala source to [...]\hello-scalajs\target\scala-2.11\classes...
[info] Fast optimizing [...]\hello-scalajs\target\scala-2.11\hello-scalajs-fastopt.js
[info] Running hello.HelloApp
Hello world!
[success] [...]
\end{lstlisting}

Damit das kleine Programm im Browser ausgeführt werden kann, muß es in eine HTML-Datei eingebunden werden, wie in Listing \ref{code:hello.html}.

\lstinputlisting[language=HTML5, caption={HTML-Code zur Einbindung der Scala.js-Datei in eine Website.}, label={code:hello.html}]{listings/01hello-scalajs/index-dev.html}

Hierbei empfehlen sich zwei getrennte HTML-Dateien, eine zur Entwicklung und eine für das fertige Produkt, in der die jeweils passenden JavaScript-Dateien zu verwenden sind. Wie in Abschnitt~\ref{sec:compiler} beschrieben, erzeugt der Scala.js-Compiler, je nach Task, \texttt{fastOptJS} oder \texttt{fullOptJS}, unterschiedliche JavaScript-Dateien, die anhand ihres Suffix, \texttt{-fastopt.js} beziehungsweise \texttt{-opt.js}, auseinandergehalten werden können.

\subsection{Ergebnisse der Untersuchung und Bewertung}

\subsubsection{Konfigurationsaufwand}

Im direkten Vergleich mit einem Programm in reinem JavaScript und HTML (Listing \ref{code:hello-js.html}):

\lstinputlisting[language=HTML5, caption={HTML-Code mit eingebettetem JavaScript für ein Hallo-Welt-Programm.}, label={code:hello-js.html}]{listings/01hello-scalajs/hello-js-index.html}

ist der Aufwand, der für ein Scala.js-Projekt mit gleicher Funktionalität betrieben werden muss deutlich größer. Was sich dort auf eine einzige Datei mit wenigen Zeilen Code beschränkt, benötigt hier Build-Definitionen, Plugins und eine ganze Projektstruktur. Andererseits schlägt sich der Gewinn, der sich daraus ergibt, typsicher in Scala für die Oberfläche zu programmieren, bei einem so trivialen Beispiel noch nicht nieder.

\subsubsection{Performance}

Hier wurde die Geschwindigkeit des Build-Laufs und die Größe der Kompilate untersucht.

Es wurde Windows 8.1 Pro auf einem System mit 64-Bit Intel Core i7-3517U Prozessor mit einem Takt von 1,9 GHz, 4 GB RAM und einem SSD-Laufwerk verwendet.

Die Ergebnisse der Untersuchung sind in den Tabellen \ref{table:compiler-performance1} und \ref{table:compiler-performance2} dargestellt.

\medskip

\begin{table}[!h]
\begin{tabular}{|l|r|r|r|r|r|r||r|r|r|r|}
\hline           & t1   & t2   & t3   & t4   & tc            & tn    & s0             & s1     & sm    & sd    \\ 
\hline fullOptJS & 10 s &  4 s &  3 s &  3 s &          2 s  & 0-1 s & \textbf{20 kB} &  77 kB & 57 kB &  0 kB \\ 
\hline fastOptJS &  7 s &  3 s &  3 s &  2 s &  \textbf{2 s} & 0-1 s &        101 kB  & 193 kB & 92 kB &  0 kB \\ 
\hline 
\end{tabular} 
\caption{Build-Performance für ein minimales Hallo-Welt-Programm.}
\label{table:compiler-performance1}
\end{table}

\medskip

\begin{table}[!h]
\begin{tabular}{|l|r|r|r|r|r|r||r|r|r|r|}
\hline           & t1   & t2   & t3   & t4   & tc            & tn    & s0             & s1     & sm     & sd     \\ 
\hline fullOptJS & 15 s &  7 s &  5 s &  5 s &          4 s  & 0-1 s & \textbf{57 kB} & 230 kB & 173 kB &   0 kB \\ 
\hline fastOptJS & 11 s &  5 s &  4 s &  4 s &  \textbf{3 s} & 0-1 s &        277 kB  & 520 kB & 243 kB &   0 kB \\ 
\hline test      & 35 s & 24 s & 24 s & 22 s &         19 s  &  16 s &        1,6 MB  & 2,8 MB & 1,2 MB & 241 kB \\ 
\hline 
\end{tabular} 
\caption{Build-Performance für ein leicht erweitertes Hallo-Welt-Programm mit Tests.}
\label{table:compiler-performance2}
\end{table}

\medskip

Die verwendeten Abkürzungen sind in der Legende \ref{table:compiler-performance-legend} aufgeschlüsselt.

\medskip

\begin{table}[!h]
\begin{tabular}{|l|l|}
\hline t1 & Dauer des 1. Compilerlaufs (target-Ordner existiert noch nicht) \\ 
\hline t2 & Dauer des 2. Compilerlauf nach einem \texttt{clean} \\ 
\hline t3 & Dauer des 3. Compilerlauf nach einem \texttt{clean} \\ 
\hline t4 & Dauer des 4. Compilerlauf nach einem \texttt{clean} \\ 
\hline tc & Dauer ab 2. Compilerlauf mit Code-Änderungen ohne \texttt{clean} \\ 
\hline tn & Dauer ab 2. Compilerlauf ohne Code-Änderungen ohne \texttt{clean} \\ 
\hline s0 & Größe der erzeugten Dateien ohne Sourcemaps \\ 
\hline s1 & Größe der erzeugten Dateien mit Sourcemaps \\ 
\hline sm & Größe der erzeugten Sourcemaps-Datei \\ 
\hline sd & Größe der erzeugten Datei, die die JavaScript-Dependencies enthält \\ 
\hline 
\end{tabular} 
\caption{Legende zu \ref{table:compiler-performance1} und \ref{table:compiler-performance2}.}
\label{table:compiler-performance-legend}
\end{table}

\medskip

Für die ermittelten Dateigrößen wurde der erzeugte Bytecode (die \texttt{.class}- und \texttt{.sjsir}-Dateien) nicht mitgerechnet.

\texttt{test} wurde immer in der FastOpt-Stage mit PhantomJS verwendet. Zwischen den Testläufen wurde nie \texttt{clean} aufgerufen. Für den ersten Testlauf existierte kein target-Ordner beziehungsweise dieser wurde zuvor gelöscht.

Es wird deutlich, dass sich der Compiler ab dem zweiten Lauf "`stabilisiert"' und selbst nach einem \textbf{clean} deutlich schneller fertig ist als beim ersten Lauf. Der für den Entwicklungsalltag häufiste Fall dürfte wohl ein Build nach Code-Änderungen ohne \textbf{clean} sein. Dafür sind 3 Sekunden eine vertretbare Zeit. Bei einem weniger trivialen Beispiel mit mehr Code wachsen diese Zeiten, bleiben aber den Erfahrungen im Laufe dieser Arbeit nach in der Regel unter 10 Sekunden (? TODO: CHECK --> clientserver oder stringanalyzer) und damit in einem vertretbaren Rahmen.

Es ist auch zu erkennen, dass Testläufe, selbst ohne Code-Änderungen nicht besonders schnell sind. In den insgesamt 7 Tests werden 25 Assertions verwendet.\footnote{
	Im Code stehen 13 Assertions, davon werden 3 jeweils in einer Schleife 5-mal aufgerufen.}
Hier darf gemutmaßt werden, ob dabei auch die Ausführungsgeschwindigkeit von PhantomJS eine Rolle spielt. Schnellere Testläufe wären hier in jedem Fall wünschenswert. Andererseits fallen etwas langsamere Tests weniger ins Gewicht, wenn man 
im kontinuierlichen Modus arbeitet (zu erreichen mit dem Kommando \texttt{\textasciitilde{}test}).

Die Größe der Kompilate übertrifft reines HTML/JavaScript (187 Bytes) um einen Faktor von etwa 100. Andererseits ist dieser Vergleich nicht ganz fair. Ein Großer Teil der von Scala.js generierten JavaScript-Datei ist die Scala-Standardbibliothek.
Der Optimierer und der Google Closure Compiler reduzieren die Code-Menge (durch Techniken wie \textit{dead code elimination} oder die aggressive Verkürzung von Variablennamen) schon sehr stark. Die Größe von Dateien voll optimiertem Scala.js-generierten JavaScript-Dateien wird deshalb mit wachsender Code-Basis des eigenen Software-Projekts nicht etwa proportional, sondern langsamer anwachsen. Li Haoyi verweist zum Beispiel auf ein eigenes Projekt mit einem Umfang von ca. 2000 Zeilen Code, welches voll optimiert noch 288 kB groß ist. (TODO! -> eigenes client-server-Bsp.) Das Problem wird weiter relativiert durch die Tatsache, dass die meisten Server ihre Daten gzip-komprimiert übertragen, was laut Haoyi die Datenlast auf etwa ein Zehntel verkleinert.\cite[\#BlobSize]{haoyi.HOS}

\subsubsection{Debugging-Qualitäten}

mit Sourcemaps
\url{http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/}
	- sinvoller Stacktrace in der Browserkonsole durch ...
	
	(siehe dazu Abb. \ref{fig:no-sourcemaps} und \ref{fig:sourcemaps})

\begin{figure}[!h]
	\centering
	\subfloat[][]{
		\includegraphics[width=0.66\textwidth]{sourcemaps1-dumb-stacktrace}
		\label{fig:sourcemaps1}
	}
	\subfloat[][]{
		\includegraphics[width=0.33\textwidth]{sourcemaps2-cryptic-code}
		\label{fig:sourcemaps2}
	}
	\caption{Ohne Sourcemaps: Wenig aussagekräftiger Stacktrace \protect\subref{fig:sourcemaps1}, navigierbar zu schwer verständlichem, generierten JavaScript-Code \protect\subref{fig:sourcemaps2}. (Quelle: eigene Anfertigung)}
	\label{fig:no-sourcemaps}
\end{figure}

\begin{figure}[!h]
	\centering
	\subfloat[][]{
		\includegraphics[width=0.66\textwidth]{sourcemaps3-smart-stacktrace}
		\label{fig:sourcemaps3}
	}
	\subfloat[][]{
		\includegraphics[width=0.33\textwidth]{sourcemaps4-legible-code}
		\label{fig:sourcemaps4}
	}
	\caption{Unterstützung durch Sourcemaps: Diagnosestärkerer Stacktrace \protect\subref{fig:sourcemaps3}, navigierbar zu verständlichem Scala-Code \protect\subref{fig:sourcemaps4}. (Quelle: eigene Anfertigung)}
	\label{fig:sourcemaps}
\end{figure}


\subsubsection{Testbarkeit}

%TODO ******

Tests möglich ...


\subsection{Schwierigkeiten}
keine (?)
\subsection{Erfolge}
Scala im Browser
zum Code springen aus der Browser-Konsole
\subsection{Bewertung: differenziert oder boolsch mit Begründung; Fazit aus Schwierigkeiten und Erfolgen}
relativ große Datei für Hallo-Welt
relativ hoher Konfigurationsaufwand im direkten Vergleich mit Hallo-Welt-JS
komfortables Debuggin mit der Chrome-Konsole und Sourcemaps - sinnvoller Stacktrace, zum Code springen aus der Browser-Konsole
Pflege von zwei index.html etwas ärgerlich
IntelliJ angenehmer



% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%\section{hello-scalajs2, hello-scalatags -- leicht erweiterte Minimalbeispiel (3)}
%
%\subsection{Ziel der Untersuchung}
%
%
%
%hello-scalatags:
%Templating (mehr Typsicherheit für Tags -> ScalaTags-Readme)
%\subsection{Kriterien der Untersuchung}
%Performance
%	Compiler
%Testbarkeit
%Konfigurationsaufwand
%\subsection{Kurzbeschreibung des Beispielprogramms}
%Hallo Welt im Browser-Fenster
%Interaktion im Browser-Fenster
%kleine Tests, die ... beweisen
%
%
%\subsection{Ergebnisse der Untersuchung}
%
%Testbarkeit
%beschreiben
%
%Konfigurationsaufwand
%beschreiben
%
%\subsection{Schwierigkeiten}
%keine(?)
%\subsection{Erfolge}
%Tests möglich
%Bibliotheken einbinden und verwenden einfach, wenn Fassade vorhanden
%\subsection{Bewertung: differenziert oder boolsch mit Begründung; Fazit aus Schwierigkeiten und Erfolgen}






% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Canvas Frenzy - Canvas, Timer und Events}

\subsection{Ziel der Untersuchung}

Bei diesem Beispiel ging es um die Erprobung des HTML5-Canvas und der DOM-API mit Scala.js. Es sollten Timer-gesteuerte Aktionen mithilfe der Methoden des \texttt{WindowTimers}-Interface und das Arbeiten mit Event-Handlern für Maus- und Keyboard-Events ausprobiert werden. Hierbei sollte einerseits geklärt werden, ob und wie solche Standardtechniken der Oberfächenprogrammierung mit Scala.js machbar sind, andererseits sollte untersucht werden, ob die Entwicklung durch die Arbeit mit Scala.js sogar erleichtert wird, oder ob das Gegenteil der Fall ist.

Gleichzeitig wurde die Scala.js Workbench im produktiven Einsatz ausprobiert und dabei auf ihre Nützlichkeit hin geprüft.

\subsection{Kriterien der Untersuchung}

\begin{enumerate}
	\item Umsetzbarkeit aller Anforderungen
	\item Leichtigkeit der Implentierung
	\item Nützlichkeit
\end{enumerate}

\subsection{Kurzbeschreibung des Beispielprogramms}

Die Anwendung erzeugt automatisch einfache Bilder, indem sie zufällig Rechtecke oder Kreise von zeichnet. Auch Position, Abmessungen, Farbe und Transparenz der Elemente sind zufallsgeneriert. Bei den Abmessungen sorgt ein Mechanismus dafür, dass die Werte nicht zu abrupt variieren, sondern sich ein etwas ruhigerer Eindruck ergibt. Dazu werden die Zufallswerte jeweils durch lineare Interpolation mit dem letzten Wert geglättet. Das Ergebnis ist beispielhaft in den Abbildungen \ref{fig:frenzy1} und \ref{fig:frenzy2} zu sehen.

Mit der Maus kann bei gedrückt gehaltener linker Maustaste auf den Canvas-Bereich gezeichnet werden. Dabei wird ein zufälliger Farbverlauf erzeugt (siehe Abb. \ref{fig:frenzy3} und \ref{fig:frenzy4}).

\begin{figure}[!h]
	\centering
	\subfloat[][Kurz nach Start.]{
		\includegraphics[width=0.46\textwidth]{canvas-frenzy/frenzy-snap01}
		\label{fig:frenzy1}
	}
	\quad
	\subfloat[][Nachdem etwas Zeit vergangen ist.]{
		\includegraphics[width=0.46\textwidth]{canvas-frenzy/frenzy-snap02}
		\label{fig:frenzy2}
	}
	\qquad
	\subfloat[][Zeichnen mit Gradienten-Stift bei angehaltenem Auto-Zeichnen.]{
		\includegraphics[width=0.46\textwidth]{canvas-frenzy/frenzy-snap03}
		\label{fig:frenzy3}
	}
	\quad
	\subfloat[][Auto-Zeichnen und Gradienten-Stift.]{
		\includegraphics[width=0.46\textwidth]{canvas-frenzy/frenzy-snap04}
		\label{fig:frenzy4}
	}
	\caption{Screenshots der Canvas-Beispielanwendung. (Quelle: eigene Anfertigung)}
	\label{fig:frenzy}
\end{figure}

Die Anwendung lässt sich durch die Tastatur steuern. Das automatische Zeichnen kann durch Betätigen der Leertaste angehalten und wieder gestartet werden. Durch Betätigen der Escape-Taste wird die Zeichenfläche geleert. Die Geschwindigkeit, in der neue Elemente gezeichnet werden durch die Pfeil-Tasten gesteuert werden: "`nach oben"' beschleunigt das Neuzeichnen, "`nach unten"' verlangsamt es.

Die Größe der Zeichenfläche wird jeweils an die aktuelle Größe des Browserfensters neu angepasst. Allerdings wird dabei auch die Zeichenfläche geleert.

((Eine Schwäche der aktuellen Implementierung ist es, dass die beim Zeichnen mit der Maus entstehende Linie bei langsamer Mausbewegung noch nicht sehr glatt erscheint. Das hängt damit zusammen, dass für jede registrierte Mausbewegung, die als MouseEvent verarbeitet werden kann, eine Teillinie gezeichnet wird. Diese ist jeweils die Verbindungslinie zwischen der Mausposition des vorigen mit der des aktuellen MouseEvent. Zwischen diesen Teillinie entsteht, wenn sie nicht in exakt dieselbe Richtung weisen, eine Lücke.

Ein anderer bekannter Fehler ist das ungewöhnliche Verhalten der Zeichenfläche beim Zoomen im Browser.))


\subsection{Ergebnisse der Untersuchung und Bewertung}

Alle geplanten Anforderungen ließen sich umsetzen: das Zeichnen auf den Canvas, der Zugriff auf die DOM-API, timergesteuerte Ausführung und die Verwendung von Event-Handlern.

Um ein Canvas-Objekt zu erhalten, gibt es in JavaScript zwei Möglichkeiten: entweder man definiert im HTML-Dokument ein Canvas-Element mit einer eindeutigen ID \texttt{<canvas id="'myCanvas"'></canvas>} und greift im JavaScript-Code darauf zu:

\begin{lstlisting}[language=JavaScript]
var canvas = document.getElementById("my-canvas")  // JavaScript
\end{lstlisting}

oder man erzeugt das Canvas-Element mit der \texttt{createElement}-Methode:

\begin{lstlisting}[language=JavaScript]
var canvas = document.createElement("canvas")      // JavaScript
\end{lstlisting}

Um diese Methoden der DOM-API in Scala.js zu verwenden, existiert die Bibliothek Scala-js-dom. Damit können die benötigten DOM-API-Methoden erwartungsgemäß verwendet werden:

\begin{lstlisting}[language=Scala]
val canvas = dom.document.getElementById("my-canvas").
  asInstanceOf[html.Canvas]
\end{lstlisting}

und in der Variante mit \texttt{createElement}:

\begin{lstlisting}[language=Scala]
val canvas = dom.document.createElement("canvas").
  asInstanceOf[html.Canvas]
\end{lstlisting}

Zu beachten ist hier der Cast mit \texttt{asInstanceOf[T]}. Die Methoden \texttt{getElementById} und \texttt{createElement}
geben nämlich ein Objekt vom Typ \texttt{org.scalajs.dom.raw.Element} zurück. Der Cast ist also notwendig, um auf die Canvas-Methoden zuzugreifen. Er ist auch legitim, denn wir wissen hier, dass es sich um ein Canvas-Objekt handeln muss.

Zum Zeichnen wird nun der 2D-Kontext benötigt. Auch hier ist aus den genannten Gründen ein Cast notwending. Danach kann der Kontext wie gewohnt verwendet werden.\footnote{Zum Zeichnen auf den Canvas siehe: \url{https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D}}

\begin{lstlisting}[language=Scala]
val ctx = canvas.getContext("2d").
  asInstanceOf[dom.CanvasRenderingContext2D]
ctx.fillStyle = "silver"
ctx.fillRect(x, y, width, heigth)
\end{lstlisting}

Die Typ-Casts mögen etwas unschön sein, aber die zwei beschriebenen Fälle sind auch die einzigen, die in der Beispielanwendung benötig werden. Sébastien Doeraene zufolge ist die erste Art Cast zur Spezialisierung des HTML-Elements, unvermeidbar, andernfalls müsste der DOM selbst Teil des Typsystems sein. Der zweite Cast zum konkreten Rendering-Kontext wird wohl in einer künftigen Version von Scala.js nicht mehr nötig sein. Doeraene weist auch darauf hin, dass in sechs Scala.js-Beispielanwendungen mit insgesamt 1000 Zeilen Code exakt diese beiden Casts, und nur diese, benötigt werden.\cite[S. 8]{doeraene2013.TDI}

Um einen Timer zu starten, der ein Aktion regelmäßig ausführt, bietet die DOM-API die Methode \texttt{setInterval}. Die folgende Anweisung erzeugt zum Beispiel einmal pro Sekunde eine Ausgabe auf die Konsole:

\begin{lstlisting}[language=JavaScript]
setInterval(function(){ console.log("hi"); }, 1000);
\end{lstlisting}

In Scala.js lässt sich das nun recht ähnlich ausdrücken:

\begin{lstlisting}[language=Scala]
dom.setInterval(() => println("hi"), 1000)
\end{lstlisting}

Hier ist also nichts neu zu lernen, die JavaScript-DOM-API wird mithilfe der Fassade einfach verwendet. Zusätzlich profitieren wir hier von der prägnanten Scala-Syntax, mit der sich Lambas knapper schreiben lassen.

Zur Veranschaulichung der Verwendung von Event-Handler sei hier folgendes Beispiel herausgegriffen:

\begin{lstlisting}[language=Scala]
dom.document.onkeyup = { (evt: dom.KeyboardEvent) => evt.keyCode match {
  case KeyCode.space =>  timer.toggle()
  case KeyCode.up =>     timer.decr()
  case KeyCode.down =>   timer.incr()
  case KeyCode.escape => clear()
  case _ => ()
}}
\end{lstlisting}

Der wird der \texttt{onkeyup}-Property eine ein Scala-Lambda zugewiesen. Durch Scalas Pattern-Matching kann sehr knapp und übersichtlich das gewünschte Verhalten formuliert werden. Scala-js-dom stellt neben Fassaden für die DOM-API im Paket \texttt{org.scalajs.dom.ext} nützliche Helfer zur Verfügung, darunter eine Liste für die meisten Keyboard-Tasten-Codes, so dass hier nicht mit kryptischen Zahlenwerten gearbeitet werden muss.

Auch schlägt sich hier der Gewinn nieder, den 
Scala befördert eine größere Abstraktion beim Programmieren. So wird es erleichtert, nach Bedarf Teile "`herauszuziehen"' (UMFORMULIEREN).

So wurde im ersten Ansatz der Timer direkt mit dem Aufruf:

\begin{lstlisting}[language=Scala]
dom.setInterval(() => action, interval)
\end{lstlisting}

gestartet. Um aber die Frequenz des automatischen Zeichnens per Keyboard-Interaktion zu steuern, muss der Timer angehalten und mit einem Intervall erneut gestartet werden. Es erwies sich daher als sauberer und für den Handler-Code entlastend und ganz im Sinne von DRY\footnote{\textit{Don't Repeat Yourself!}}, eine Timer-Abstraktion einzuführen:


*** HIER ***


Statt etwa direkt den
	- z.B. Timer:
		timer.start() statt direkt:
		dom.setInterval(() => action, interval)
		
		dadurch knappe und schnell verständlicher Code:
\begin{lstlisting}[language=Scala]
dom.document.onkeyup = { (evt: dom.KeyboardEvent) => evt.keyCode match {
  case KeyCode.down =>   timer.incr()
  [...]
}}
\end{lstlisting}

		Details in Timer verborgen:
		
\begin{lstlisting}[language=Scala]
class Timer(var interval: Int, action: => Unit) {
  var timerId = -1
  val inc = 2

  def start() =
     timerId = dom.setInterval(() => action, interval)
   
  def incr() = {
    interval *= inc
    updateInterval()
  }

  private def updateInterval() = {
    dom.clearInterval(timerId)
    timerId = dom.setInterval(() => action, interval)
  }
}
\end{lstlisting}












>>Scala-js-dom       **** UP % ^^^

hinzufügen in der build.sbt - zack, fertig:

\begin{lstlisting}
libraryDependencies += "org.scala-js" %%% "scalajs-dom" % "0.8.0"
\end{lstlisting}





>>Gewinn durch Möglichkeit der Verwendung von Scala  ------- siehe oben - einarbeiten!!!

Die Typsicherheit hat hier beim Editieren den unmittelbaren Vorteil, dass die IDE-Unterstützung

\begin{figure}[!h]
    \centering
    \includegraphics[
    width=1.0\textwidth
%   scale=0.5
    ]{typesafe-autocomplete}
    \caption{Intelligente Auto-Vervollständigung in IntelliJ.
    (Quelle: eigene Anfertigung)
    }
    \label{fig:typesafe-autocomplete}
\end{figure}


	-> Contra (?) bzw. Achtung ->  man muss durch Disziplin selbst darauf achten, dass man js.Dynamic vermeidet und ggf. castet, ist aber selten nötig (-> andere Beispiele???)





\paragraph{Workbench-Plugin}

Damit das Workbench-Plugin von sbt auch geladen wird, muss es in der \texttt{text} hinzugefügt werden:

\begin{lstlisting}
addSbtPlugin("com.lihaoyi" % "workbench" % "0.2.3")
\end{lstlisting}

In der build.sbt müssen folgende zwei Einträge hinzugefügt weden:
\begin{lstlisting}
bootSnippet := "frenzy.CanvasApp().main();"

updateBrowsers <<= updateBrowsers.triggeredBy(fastOptJS in Compile)
\end{lstlisting}

Das \texttt{bootSnippet} legt fest, welcher JavaScript als Einsprungspunkt für das Neuladen verwendet werden soll. Manchmal genügt ein \texttt{updateBrowsers} nicht, für solche Fälle existiert das radikalere:

\begin{lstlisting}
refreshBrowsers <<= refreshBrowsers.triggeredBy(fastOptJS in Compile)
\end{lstlisting}

Nun muss die Workbench noch in der Entwicklungsversion des HTML-Dokuments eingebunden werden durch folgenden Code-Schnipsel:

\begin{lstlisting}
<script src="/workbench.js"></script>
\end{lstlisting}

Hierbei ist es wichtig, darauf zu achten, dass diese Zeile nach allen anderen JavaScript-Einbindungen ganz am Ende im \texttt{<body>} steht.

Beim Start von sbt wird nun automatisch das Workbench-Plugin geladen. Dieses startet einen lokalen Server für das Projektwurzelverzeichnis unter der Adresse \url{localhost/127.0.0.1:12345}. Dadurch ist mit der Eingabe der Adresse \url{http://localhost:12345/target/scala-2.11/classes/index-dev.html} im Browser die Scala.js-Anwendung erreichbar.

Zur flüssigen Entwicklung ist es am komfortabelsten, im kontinuierlichen Modus zu arbeiten. Dazu wird nun \texttt{\textasciitilde{}fastOptJS} aufgerufen, wodurch jedes Speichern von Code-Änderungen einen Build triggert. Ist hierbei die Workbench gestartet, muss das Terminal während der Entwicklung seltener aufgesucht werden, denn selbst Ausgaben des Compilers werden nützlicherweise in der Browser-Konsole ausgegeben (siehe Abb. {fig:workbench-in-action1} - {fig:workbench-in-action4}).

\begin{figure}[!h]
    \centering
    \includegraphics[
    width=1.0\textwidth
%   scale=0.5
    ]{workbench-in-action1}
    \caption{Ausgabe des Scala.js-Compilers in der Browser-Konsole.
    (Quelle: eigene Anfertigung)
    }
    \label{fig:workbench-in-action1}
\end{figure}

\begin{figure}[!h]
    \centering
    \includegraphics[
    width=1.0\textwidth
%   scale=0.5
    ]{workbench-in-action2}
    \caption{Fehlerausgabe des Scala.js-Compilers in der Browser-Konsole.
    (Quelle: eigene Anfertigung)
    }
    \label{fig:workbench-in-action2}
\end{figure}

Das Workbench-Plugin funktioniert nicht immer ganz zuverlässig, und manchmal muss das Browserfenster per Hand neu geladen werden. Alles in allem ist es aber ein sehr hilfreiches Entwicklungswerkzeug für ein flüssigeres Arbeiten.


\subsection{Schwierigkeiten}

\subsection{Erfolge}


\subsection{Bewertung: differenziert oder boolsch mit Begründung; Fazit aus Schwierigkeiten und Erfolgen}


















% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%\section{scalajs-showcase - der Rest:  umfangreichere Templates, Events (3)}
%
%\subsection{Untersuchungsziele}
%\subsection{Untersuchungskriterien}
%\subsection{Kurzbeschreibung des Beispielprogramms}
%\subsection{Untersuchungsergebnisse}
%\subsection{Schwierigkeiten}
%\subsection{Erfolge}
%\subsection{Bewertung: differenziert oder boolsch mit Begründung; Fazit aus Schwierigkeiten und Erfolgen}



% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Textanalyzer - ein umfangreicheres Beispiel}

%TODO#############################

\subsection{Ziel der Untersuchung}
\subsection{Untersuchungskriterien}
\subsection{Kurzbeschreibung des Beispielprogramms}
\subsection{Ergebnisse der Untersuchung und Bewertung}
\subsection{Schwierigkeiten}
\subsection{Erfolge}
\subsection{Bewertung: differenziert oder boolsch mit Begründung; Fazit aus Schwierigkeiten und Erfolgen}



% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Currency Converter - Ajax}

%TODO#############################

\subsection{Ziel der Untersuchung}

Die Kommunikation mit Objekten ((?)) außerhalb des Web-Clients, wie zum Beispiel mit Webservices, ist ein wichtiger Bestandteil der allermeisten interaktiven Web-Anwendungen. Dazu wird standardmäßig eine als \texttt{Ajax} bezeichnete Technik verwendet. Dabei werden aus der Web-Anwendung heraus über das HTTP-Protokoll Daten von einem Server angefragt, um auf Grundlage der Antwort Teile der HTML-Seite zu aktualisieren. Diese Standardtechnik und die Behandlung von Asynchronität mit Scala.js sollte erprobt werden.

\subsection{Untersuchungskriterien}

\begin{enumerate}
	\item Konfigurationsaufwand
	\item Umsetzbarkeit aller Anforderungen
	\item Leichtigkeit der Implementierung
	\item Code-Qualität (Typsicherheit, Lesbarkeit, Wartbarkeit)
\end{enumerate}

\subsection{Kurzbeschreibung des Beispielprogramms}

Beispielhaft wurde ein Währungsumrechner umgesetzt, der dem Benutzer die Eingabe des Betrags und die Auswahl von Quell- und Zielwährung per Auswahlliste anbietet, und auf Knopfdruck oder Betätigung der Entertaste hin die Umrechnung auf der Basis tagesaktueller Kurse durchführt. Beträge werden bis auf vier Nachkommastellen hin genau dargestellt. Die Eingabe ist fehlertolerant gegenüber ungültigen Beträgen. Als kleiner Komfort kann der Betrag mit der Escape-Taste auf 1.0000 zurückgesetzt werden.

\begin{figure}[!h]
    \centering
    \includegraphics[
    width=1.0\textwidth
%   scale=0.5
    ]{currency-converter/currency-converter}
    \caption{Der Währungsumrechner.
    (Quelle: eigene Anfertigung)
    }
    \label{fig:converter}
\end{figure}

\subsection{Ergebnisse der Untersuchung und Bewertung}

Ist das Setup einer einfachen Scala.js-Anwendung einmal erprobt, bleibt der weitere Konfigurationsaufwand für diese Anwendung gering: die benötigten Bibliotheken müssen lediglich als \texttt{libraryDependencies} in der Build-Definition hinzugefügt werden.

Das Umrechnungsformular lässt sich mit ScalaTags sehr übersichtlich und deklarativ schreiben. Es werden zwei nahezu identische Währungsauswahllisten benötigt, mit einem Unterschied: Der Auswahlwert soll unterschiedlich behandelt werden soll, einmal als Quell-, das andere Mal als Zielwährung. Der Methode, die Auswahllisten erzeugt muss daher eine Funktion \texttt{String => Unit}) übergeben werden, die den Auswahlwert entgegennimmt, so dass der Umrechner passend aktualisiert werden kann.

\begin{lstlisting}[language=Scala]
def setupCurrencySelect(theId: String,
                        updateConverter: String => Unit,
                        defaultOption: String = "EUR"): html.Select = {
  val sel = select(
    id:=theId,
    for ((code, name) <- Converter.currencies.toSeq) yield option(
      id:=s"$theId-opt-${code.toLowerCase}",
      value:=code, name
    )
  ).render
  sel.onchange = (e: dom.Event) => updateConverter(sel.value)
  sel.value = defaultOption
  sel
}
\end{lstlisting}

Die Liste der möglichen \texttt{<option>}s lässt sich prägnant mithilfe einer \texttt{for}-Comprehension ausrücken.

Das Auswahllisten-Elemente, bei dem es sich um ein \texttt{scalatags.JsDom.TypedTag[html.Select]} handelt, muss durch Aufruf der Methode \texttt{render} in den Fassadentyp \texttt{html.Select} der Scala-js-dom-Bibliothek umgewandelt werden. Dadurch haben wir vollen, typsicheren Zugriff auf die Methoden und Attribute ((die in der DOM-API spezifiziert sind)). Ein \texttt{onchange}-Handler ließe sich eigentlich auch innerhalb des \texttt{select( ... )}-Tags schreiben, allerdings ließe sich so nicht auf das \texttt{value}-Attribut zugreifen.

Nach diese Vorbereitung kann das Umrechnungsformular sehr übersichtlich und deklarativ geschrieben werden:

\begin{lstlisting}[language=Scala]
container.appendChild(
  div(
    h1("Currency Converter"),
    form(
      id:="form-conv",
      onsubmit:={ (evt: dom.Event) => evt.preventDefault() },
      inputAmount,
      setupCurrencySelect("sel-src-curr", c => converter = converter.copy(srcCurr = c)),
      outputAmount,
      setupCurrencySelect("sel-dst-curr", c => converter = converter.copy(dstCurr = c)),
      button(
        id:="btn-do-get",
        cls:="input-btn",
        "Convert",
        onclick:={ () => updateDstAmount() }
      )
    )
  ).render
)
\end{lstlisting}

Das Eingabefeld für den Ausgangsbetrag \texttt{inputAmount} ebenso wie das Ergebnisfeld \texttt{outputAmount} wurden zuvor definiert und mit \texttt{.render} umgewandelt, um sie im Programm referenzieren zu können. Auf diese Art ist es nicht nötig, den Umweg über \texttt{document.getElementById()} oder mit jQuery-Selektoren zu gehen.

Als Quelle für die Umrechnungskurse sollte die Yahoo! Finance API\footnote{
	\url{https://code.google.com/p/yahoo-finance-managed/wiki/YQLAPI}}
genutzt werden, die auf HTTP-Anfrage Ergebnisse im JSON-Format\footnote{
	JavaScript Object Notation, ein kompaktes Format zum Datenaustausch.}
liefert

\begin{lstlisting}[language=Scala]
case class Converter(
  srcCurr: String = "EUR",
  dstCurr: String = "EUR"
) {
  def convert(srcAmount: Double): Future[Double] = async{
    srcAmount * await{ rate }
  }

  private def url = "http://query.yahooapis.com/v1/public/yql?q=select * from yahoo.finance.xchange where pair in ('" +
    srcCurr + dstCurr + "')&format=json&env=store://datatables.org/alltableswithkeys"

  private lazy val rate: Future[Double] = Ajax.get(url).map{ case xhr =>
    val json: js.Dynamic = js.JSON.parse(xhr.responseText)
    assert(json.query.results.rate.id.toString == srcCurr + dstCurr)
    json.query.results.rate.Rate.toString.toDouble
  }
}
\end{lstlisting}

TODO  -->  vgl. Using Web Services \cite[\#UsingWebServices]{haoyi.HOS}

... HIER *** %TODO ***



\subsection{Schwierigkeiten}




\subsection{Erfolge}
\subsection{Bewertung: differenziert oder boolsch mit Begründung; Fazit aus Schwierigkeiten und Erfolgen}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{js-interop -> playground(?) (3)}

\subsection{Ziel der Untersuchung}
\subsection{Untersuchungskriterien}
\subsection{Kurzbeschreibung des Beispielprogramms}
\subsection{Ergebnisse der Untersuchung und Bewertung}
\subsection{Schwierigkeiten}
\subsection{Erfolge}
\subsection{Bewertung: differenziert oder boolsch mit Begründung; Fazit aus Schwierigkeiten und Erfolgen}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{crosscompiling-statistics-lib, js-port-of-statistics-lib, benchmarks (TODO) (3)}

%TODO#############################

\subsection{Ziel der Untersuchung}
\subsection{Untersuchungskriterien}
\subsection{Kurzbeschreibung des Beispielprogramms}
\subsection{Ergebnisse der Untersuchung und Bewertung}
\subsection{Schwierigkeiten}
\subsection{Erfolge}
\subsection{Bewertung: differenziert oder boolsch mit Begründung; Fazit aus Schwierigkeiten und Erfolgen}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{clientserver - minimales Client/Server-Setup mit Routing (3)}

%TODO#############################

\subsection{Ziel der Untersuchung}
eine (!) Templating-Sprache für Server und Client: ScalaTags \cite{haoyi.HOS}
eine (!) Library zur Serialisierung: uPickle \cite{haoyi.HOS}
Schnittstelle in einer Sprache

\subsection{Untersuchungskriterien}
\subsection{Kurzbeschreibung des Beispielprogramms}
entsprechend Code-Vorschlägen von Li Haoy\cite{haoyi.HOS}
\subsection{Ergebnisse der Untersuchung und Bewertung}
\subsection{Schwierigkeiten}
\subsection{Erfolge}
\subsection{Bewertung: differenziert oder boolsch mit Begründung; Fazit aus Schwierigkeiten und Erfolgen}
- muss nicht zwei Libraries für Client und Server finden
- leichter nur eine (!) Library (jeweils für Templating und Serialisierung) zu lernen, die in Client und Server verwendet werden kann
\cite[\#SharingCode]{haoyi.HOS}
- relativ einfache statisch typisierte RPCs mit autowire


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Auswertung (speziell der "`weichen"' Kriterien)}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Fazit}

\section{Zusammenfassung der Ergebnisse}

TODO - NACH FERTIGSTELLUNG DER ÜBRIGEN KAPITEL NEU SCHREIBEN!

Die vorliegende Arbeit ...
- Überblick über Entwicklung von Weboberflächen mit Scala.js
- Eignung aus Anwendersicht ...
- Eignung aus Entwicklersicht ...
- Vorteile ...
- Nachteile ...





>> was spricht für Scala.js?
    nach nicht-repräsentativer Umfrage (
      vgl.  -->  \url{http://www.scala-lang.org/news/2015/02/05/scala-js-no-longer-experimental.html}
      Diskussion hier  -->  \url{https://groups.google.com/forum/#!topic/scala-js/_1Sfb5Nj08w}
    ):
    - geteilter Code zwischen Client und Server, eine Sprache für die gesamte Anwendung, z.B. für Validierungs-Logik, aber auch Wiederverwendbarkeit von Code (wenn keine Plattformspezifika direkt verwendet werden)
    \cite{doeraene2013.CSJ}
    - starke Typisierung, auch für JavaScript-Libraries
    - Tooling: IDE-Support, sbt-Integration, Dependency-Management, Unit-Tests, Stacktraces und Sourcemaps, kross-compilierende Projekte
    - Portababilität: Scala auf JavaScript-basierten Plattformen

  kompletter Scala-Support
  
  schnelle Ints:
  - Int-Operationen werden durch bitweise Veroderung umgesetzt (z.B. Scala.js: a + b -> JS: (a + b) | 0)
  - JS VMs verwenden intern int32 als Optimierung für bitweise Operationen
  -> schneller\cite{doeraene2015.SSP}


  schneller Dev-cycle, optim. Prod.code
  
  
was fehlt?
  (- checked Exceptions???)
  (- Regex???)
  - Unterstützung von Reflection

Schwächen
  - relativ große Dateien
  (- Debugging schwieriger???)
  - Support für einige Libraries
  - Performance
  
Unbequemlichkeiten
  - Auslieferung von Produktionscode noch etwas mühsam: kompiliert nach
\begin{lstlisting}
target/
  +- scala-2.11/
  +- [...]-opt.js
  +- [...]-jsdeps.min.js
  +- classes/
      +- index.html
      +- [...].css
\end{lstlisting}
  - muss per Hand extrahiert werden
  - wenn andere Ordnerstruktur gewünscht ist, z.B.:
\begin{lstlisting}
webapp/
 +- js/
 |   +- [...]-opt.js
 |   +- [...]-jsdeps.min.js
 +- css/
 |   +- [...].css
 +- index.html
\end{lstlisting}
  ... dann müssen die Pfade in der index.html entsprechend geändert werden
  -> Lösung wären hier entsprechende Export-Skripte; bzw. denkbar, dass in Zukunft ein entsprechendes Tool oder sbt-Plugin (?) angeboten wird



großes Potential
	besonders weil: eine Sprache für Client und Server
		Wiederverwendbarkeit von Code
		nur in einer Sprache denken, nicht eine weitere lernen
	typbedingte Laufzeitfehler auch für Client-Seite (JavaScript) ausgeschlossen sind
	mit Templating-Library auch HTML-Tags typsicher macht
	
Doku noch im Wandel, stellenweise ("`tiefer drin"') noch etwas sparsam erklärt, zeitweise und sporadisch nicht mit den neuesten Änderungen synchron, aber im Großen und Ganzen ziemlich gut

vor allem für Entwickler und Projekte die schon mit Scala arbeiten sehr interessant

Erfolg hängt sicher auch am Erfolg der Sprache Scala
dafür, dass noch sehr jung, schon sehr gut entwickelt und anscheinend stabil





\section{Ausblick}

TODO - NACH FERTIGSTELLUNG DER ÜBRIGEN KAPITEL NEU SCHREIBEN!

Blick über den Tellerrand:
- anderer vielversprechender Ansatz: Elm
	-->  \url{http://elm-lang.org/}
	- FRP (Functional Reactive Programming) Sprache um deklarativ UIs für den Browser zu schreiben, statisch typisiert
	- kompiliert nach HTML, CSS und JavaScript
	- hat REPL, package manager, debugger
	- libraries
	- Alternative zu Scala.js? - kein Scala, nur Client...



Weiterentwicklung

	ganz neu (aber nicht untersucht): \url{http://www.scala-js.org/doc/sjs-defined-js-classes.html}
	SJS-Klassen von JS-Klassen erben lassen  -->  \url{https://github.com/scala-js/scala-js/issues/1795}
	
	
	angekündigt: Compiler im Browser\cite{doeraene2014.WHB}
	



professionelle Anwendungen mit Scala.js

		https://jaxenter.com/happy-tenth-birthday-scala-whats-next-107440.html
	https://jaxenter.de/scala-javascript-compiler-scalajs-0-6-0-produktionseinsatz-13633
	- die Frage ist, ob Frontend/Client-side-Entwickler bereit sind, auf Scala.js umzusteigen (ohne vorherige Scala-Kenntnisse, und die sind i.d.R. nicht anzunehmen), aber es könnte ein großer Gewinn sein: Vorteile mit Scala zu arbeiten\cite{doeraene2013.CSJ}




Ausblick
  - (hoffentlich) schnell (?) wachsender Library-Support, 
     	- gerade wegen der Erweiterbarkeit von Scala auch bei kleiner (aber reger und enthusiastischer) Scala.js-Community  recht wahrscheinlich
  - Performance-Verbesserungen
  - professioneller Einsatz?
    -->  \url{https://www.reddit.com/r/scala/comments/2spdlq/is_anyone_using_scalajs_in_nontrivial/}





% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\appendix
\chapter{Quellcodeauszüge usw.}

\section{Beispielabbildung}

blabla (siehe Abb. \ref{fig:a_picture_of_tux}) blabla

\begin{figure}[!h]
    \centering
    \includegraphics[
    width=0.25\linewidth
%   scale=0.5
    ]{tux}
    \caption{Eine Beispielabbildung.
    (Quelle: \cite{aab.FBB})
    }
    \label{fig:a_picture_of_tux}
\end{figure}

blabla


\section{Beispielcode}

blabla \verb|println(this)| blabla

blablba \verb|var sqr = function(x) { return x * x; }| blabla

\verb|var sqr = function(x) { return x * x; }|

\begin{verbatim}
var sqr = function(x) { return x * x; }
for (var i = 0; i < 10; i++) {
  console.log(i, sqr(i));
}
\end{verbatim}

% possible to emph and textbf, but curly braces have to be escaped:
\begin{alltt}
var \emph{sqr} = function(x) \{ \textbf{return} x * x; \}
for (var i = 0; i < 10; i++) \{
  console.log(i, \emph{sqr}(i));
\}
\end{alltt}


Ein kleines JavaScript-Codeschnipsel könnte man \lstinline[language=JavaScript, style=inline]!function(x) { return 2 + x; }! inline schreiben. Und ein kleines Scala-Codeschnipsel könnte man \lstinline[language=Scala, style=inline]|def foo(): Unit = println("bar")| inline schreiben.


\begin{lstlisting}
var sqr = function(x) { return x * x; }
for (var i = 0; i < 10; i++) {
  console.log(i, sqr(i));
}
\end{lstlisting}

Some Python code:
\lstinputlisting[language=Python, xleftmargin=10pt, caption={This is just a Python example}]{listings/example.py}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %


Some Scala code:
\lstinputlisting[language=Scala, caption={And this is a very stupid Scala example}]{listings/example.scala}

And again some Scala code:
\lstinputlisting[language=Scala, linerange={3-6,16-31}, style=uncolored, style=numbered, caption={An excerpt from the very same example}]{listings/example.scala}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %


Some JavaScript code:
\lstinputlisting[language=JavaScript, caption={A JavaScript example}, firstline=3, lastline=39, style=unframed, style=numbered, frame=single, rulecolor=\color{blue}]{listings/example.js}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %


Some HTML code with line numbers:
\lstinputlisting[language=HTML5, style=numbered, caption={And finally a HTML example}]{listings/example.html}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %




% ABBILDUNGSVERZEICHNIS ERSTELLEN
\listoffigures

% TABELLENVERZEICHNIS ERSTELLEN
\listoftables

% QUEELLCODEVERZEIHCHNIS ERSTELLEN
\lstlistoflistings

% LITERATURVERZEICHNIS ERSTELLEN
%\begin{thebibliography}{xxxxxxxxxxxxxxxxxxx}
%   \bibitem[BECK, ????]{BECK} Beck, Kent: Extreme Programming : Das Manifest, Addison-Wesley, ORT, JAHR. % TODO
%   \bibitem[ARIS, ????]{ARIS} Arisholm, Erik; Gallis, Hans; Dyb\aa , Tore; Sj\o berg, Dag I.K.: TITEL. In: IEEE Transcactions on Software
%    Engineering, Vol. 33, No. 2, Februar 2007.
%
%
%
%   \bibitem[GoF, 1994]{GoF1} Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides: Design Patterns: Elements of reusable object oriented software Addison Wesley Publishing Company 1994, ISBN 0-201-63361-2
%   \bibitem[BMBF, 2003]{bmbf}"'IT-Ausstattung der allgemein bildenden und berufsbildenden Schulen in Deutschland"', http://www.schulen-ans-netz.de/neuemedien/fakten/dokus/it-ausstattung-2003.pdf, 10.03.2005
%\end{thebibliography}


% TODO: nocite entfernen, damit nur zitierte Literatur ins Verzeichnis kommt
\nocite{*}


% Bibliographie mit bibtex
%\bibliographystyle{alphadin}
%\bibliography{biblio_scalajs}


% Bibliographie mit biblatex/biber
\printbibliography



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END DOCUMENT // HIER HÖRT DER INHALT AUF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}








